<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>P2P File Share ¬∑ WebRTC + PeerJS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Seguridad b√°sica -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' https://unpkg.com https://peerjs.com; script-src 'self' https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https: wss:; img-src 'self' data:; base-uri 'none'; frame-ancestors 'none'">
  <style>
    :root { --bg:#0b1020; --card:#141a2a; --muted:#9fb0d0; --accent:#46c3ff; --ok:#38d39f; --warn:#ffcc00; --err:#ff6677; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:white;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
    .wrap{max-width:900px;margin:auto;padding:16px}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1{font-size:1.4rem;margin:0 0 8px} h2{font-size:1.1rem;margin:14px 0 8px;color:var(--accent)}
    .row{display:grid;gap:12px;grid-template-columns:1fr} @media(min-width:720px){.row{grid-template-columns:1fr 1fr}}
    label{display:block;font-size:.9rem;margin:.4rem 0 .2rem;color:var(--muted)}
    input[type="text"],input[type="url"],input[type="number"],select{width:100%;padding:10px;border-radius:12px;border:1px solid #2a324a;background:#0f1424;color:white}
    input[type="checkbox"]{transform:scale(1.2)}
    input[type="file"]{border:1px dashed #2a324a;border-radius:12px;padding:10px;background:#0f1424}
    button{cursor:pointer;border:0;border-radius:12px;padding:10px 14px;background:var(--accent);color:#001019;font-weight:700}
    button.ghost{background:transparent;border:1px solid #2a324a;color:#bcd}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break:break-all}
    .grid2{display:grid;gap:10px;grid-template-columns:1fr auto}
    .progress{height:14px;background:#0f1424;border-radius:999px;overflow:hidden;border:1px solid #2a324a}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#7ff);transition:width .15s}
    .status{white-space:pre-wrap;background:#0f1424;border-radius:12px;padding:12px;min-height:100px;max-height:240px;overflow:auto;border:1px solid #2a324a}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#0f1424;border:1px solid #2a324a;margin-right:6px;font-size:.8rem}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    a{color:#7fd8ff}
  </style>
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js" integrity="sha384-Nc3z3lIbjo4iC7cLW6Z0pQPCf2Bzqkbk1bAH6QOqVgd1m8J1E6b8i2rU8cG3Fv0w" crossorigin="anonymous"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>üì¶ P2P File Share (WebRTC + PeerJS)</h1>
      <p class="muted">Selecciona un fichero ‚Üí comparte la URL ‚Üí el receptor abre la URL y descarga. Mant√©n este navegador abierto hasta finalizar ‚úÖ.</p>

      <div class="row">
        <section>
          <h2>1) Configuraci√≥n de se√±alizaci√≥n / ICE (opcional)</h2>
          <div class="row">
            <div>
              <label>Servidor PeerJS (vac√≠o = Cloud)</label>
              <input id="host" type="text" placeholder="p.ej. peerjs.com o tu.domino.com">
            </div>
            <div>
              <label>Secure (HTTPS/WSS)</label>
              <select id="secure">
                <option value="true" selected>true</option>
                <option value="false">false</option>
              </select>
            </div>
            <div>
              <label>Puerto</label>
              <input id="port" type="number" placeholder="443">
            </div>
            <div>
              <label>Path</label>
              <input id="path" type="text" placeholder="/" />
            </div>
          </div>
          <details>
            <summary>ICE servers (STUN/TURN)</summary>
            <label>STUN URLs (coma separadas)</label>
            <input id="stun" type="text" placeholder="stun:stun.l.google.com:19302, stun:global.stun.twilio.com:3478?transport=udp">
            <label>TURN URL (opc., p.ej. turn:turn.example.com:3478)</label>
            <input id="turnUrl" type="text" placeholder="turn:turn.example.com:3478">
            <label>TURN usuario</label>
            <input id="turnUser" type="text" placeholder="usuario">
            <label>TURN contrase√±a</label>
            <input id="turnPass" type="text" placeholder="contrase√±a">
          </details>
          <div style="margin-top:8px">
            <button id="btnInit">Inicializar Peer</button>
            <span class="pill">Peer ID: <span id="peerId" class="mono">‚Äî</span></span>
            <span class="pill">Servidor: <span id="srvInfo" class="mono">Cloud (auto)</span></span>
          </div>
        </section>

        <section>
          <h2>2) Compartir / Recibir</h2>
          <label>Tu fichero</label>
          <input id="fileInput" type="file" />
          <div class="grid2" style="margin-top:8px">
            <button id="btnShare" disabled>Generar URL de recepci√≥n</button>
            <button id="btnCopy" class="ghost" disabled>Copiar URL</button>
          </div>
          <label>URL para receptor</label>
          <input id="shareUrl" type="url" readonly>
          <div style="margin-top:6px">
            <span class="pill">Rol: <strong id="role">auto</strong></span>
            <span class="pill">Conectado a: <span id="remoteId" class="mono">‚Äî</span></span>
          </div>

          <h2>Progreso</h2>
          <div class="progress"><div id="bar" class="bar"></div></div>
          <div class="grid2">
            <div class="muted">Enviado/Recibido: <span id="progressTxt">0 / 0</span></div>
            <div class="muted" style="text-align:right">Estado: <span id="state">Idle</span></div>
          </div>

          <div id="downloadBox" style="display:none;margin-top:10px">
            <a id="downloadLink" download class="pill">Descargar fichero recibido</a>
          </div>
        </section>
      </div>

      <h2>Logs & Diagn√≥stico</h2>
      <div class="status" id="log"></div>

      <details style="margin-top:10px">
        <summary>‚ö†Ô∏è Consejos de seguridad/buenas pr√°cticas</summary>
        <ul>
          <li>No cierres ni recargues el navegador emisor hasta que la barra llegue al 100% y el receptor confirme la descarga.</li>
          <li>Evita enviar ficheros extremadamente grandes; este demo mantiene todo el fichero en memoria en el receptor (seguro <strong>&lt; 1&nbsp;GB</strong>). Para producci√≥n usa <em>streams</em> (WritableStream/StreamSaver) y reanudaci√≥n.</li>
          <li>Si est√°s tras NAT restrictivo, configura servidores <strong>TURN</strong> propios (con credenciales). STUN solo descubre rutas, no retransmite datos.</li>
          <li>Verifica la URL de recepci√≥n manualmente si compartes fuera de tu LAN.</li>
        </ul>
      </details>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /*** Utilidades UI ***/
  const $ = id => document.getElementById(id);
  const log = (msg, lvl='info') => {
    const time = new Date().toLocaleTimeString();
    const color = lvl==='err'?'var(--err)':(lvl==='warn'?'var(--warn)':'#bcd');
    $('log').innerText += `[${time}] ${msg}\n`;
    $('log').scrollTop = $('log').scrollHeight;
    // Colorizado simple (no innerHTML para evitar XSS)
  };
  const setState = s => $('state').innerText = s;
  const setBar = (num, den) => {
    const pct = den ? Math.min(100, Math.round((num/den)*100)) : 0;
    $('bar').style.width = pct + '%';
    $('progressTxt').innerText = human(num) + ' / ' + human(den);
  };
  const human = b => {
    if (!Number.isFinite(b)) return '0 B';
    const u = ['B','KB','MB','GB','TB']; let i=0; let n=b;
    while(n>=1024 && i<u.length-1){n/=1024;i++}
    return n.toFixed(n<10?2:1)+' '+u[i];
  };

  /*** Estado global ***/
  let peer = null;
  let conn = null;
  let isSender = false;
  let selectedFile = null;
  let retryCount = 0;
  const MAX_RETRIES = 3;

  /*** DOM ***/
  $('btnInit').addEventListener('click', initPeer);
  $('fileInput').addEventListener('change', e => {
    selectedFile = e.target.files && e.target.files[0] ? e.target.files[0] : null;
    $('btnShare').disabled = !selectedFile || !peer || peer.disconnected;
  });
  $('btnShare').addEventListener('click', createShareUrl);
  $('btnCopy').addEventListener('click', () => {
    $('shareUrl').select(); document.execCommand('copy');
    log('URL copiada al portapapeles.');
  });

  // Autodetectar modo receptor si hay ?from=<peerId> en la URL
  const url = new URL(location.href);
  const fromId = url.searchParams.get('from');
  if (fromId) {
    $('role').innerText = 'Receptor';
  } else {
    $('role').innerText = 'Emisor (por defecto)';
  }

  // Inicializa autom√°ticamente para reducir fricci√≥n
  // (pero permite ajustar opciones antes si se desea)
  // Damos un peque√±o retraso para que el usuario edite campos si quiere.
  setTimeout(() => { /* no auto init if user is typing */ }, 300);

  /*** PeerJS ***/
  function buildPeerOptions(){
    const host = $('host').value.trim();
    const secure = $('secure').value === 'true';
    const port = $('port').value ? parseInt($('port').value,10) : (secure?443:80);
    const path = $('path').value.trim() || '/';
    const stunList = ($('stun').value||'').split(',').map(s=>s.trim()).filter(Boolean);
    const turnUrl = $('turnUrl').value.trim();
    const iceServers = [];
    // STUN por defecto si no hay nada
    if (!stunList.length) {
      iceServers.push({ urls: 'stun:stun.l.google.com:19302' });
      iceServers.push({ urls: 'stun:global.stun.twilio.com:3478?transport=udp' });
    } else {
      stunList.forEach(u => iceServers.push({ urls: u }));
    }
    if (turnUrl) {
      const username = $('turnUser').value;
      const credential = $('turnPass').value;
      const turn = { urls: turnUrl };
      if (username) turn.username = username;
      if (credential) turn.credential = credential;
      iceServers.push(turn);
    }
    const base = { debug: 2, config: { iceServers } };
    if (host) Object.assign(base, { host, port, path, secure });
    return base;
  }

  async function initPeer(){
    if (peer && !peer.destroyed) try { peer.destroy(); } catch {}
    const opts = buildPeerOptions();
    const usingCloud = !('host' in opts);
    $('srvInfo').innerText = usingCloud ? 'Cloud (auto)' :
      `${opts.secure?'wss':'ws'}://${opts.host}:${opts.port}${opts.path}`;
    log(`Inicializando PeerJS‚Ä¶ Servidor: ${$('srvInfo').innerText}`);
    peer = new Peer(opts);

    peer.on('open', (id) => {
      $('peerId').innerText = id;
      log(`Peer abierto con ID ${id}.`);
      setState('Listo');

      // Si somos receptor (hay ?from=), conectar al emisor
      if (fromId) connectTo(fromId);
    });

    peer.on('disconnected', () => {
      log('Desconectado de se√±alizaci√≥n. Intentando reconectar‚Ä¶', 'warn');
      setState('Desconectado (reintentando‚Ä¶)');
      if (retryCount < MAX_RETRIES) {
        retryCount++;
        try { peer.reconnect(); } catch {}
      } else {
        log('L√≠mite de reintentos alcanzado. Revisa el servidor Peer o tu red.', 'err');
      }
    });

    peer.on('error', (err) => {
      log('Peer error: ' + (err && err.message ? err.message : String(err)), 'err');
      setState('Error');
    });

    peer.on('close', () => {
      log('Peer cerrado.', 'warn');
      setState('Cerrado');
    });

    // Aceptar conexiones entrantes (somos emisor si recibimos una conexi√≥n)
    peer.on('connection', (c) => {
      log(`Conexi√≥n entrante de ${c.peer}`);
      conn = c;
      $('remoteId').innerText = c.peer;
      isSender = true; // quien recibe la conexi√≥n empuja el fichero
      setupDataConnHandlers(conn);
      // Enviar metadatos y luego datos si ya hay fichero
      if (selectedFile) startSend();
      else log('Selecciona un fichero para empezar la transferencia.');
    });

    // Habilitar compartir si ya hay fichero
    $('btnShare').disabled = !selectedFile;
  }

  function createShareUrl(){
    if (!peer || peer.disconnected) { log('Inicializa el Peer primero.', 'warn'); return; }
    if (!selectedFile) { log('Selecciona un fichero antes.', 'warn'); return; }
    // Quien comparta la URL actuar√° como EMISOR (espera conexi√≥n del receptor)
    // El receptor abrir√° con ?from=<peerId>
    const u = new URL(location.href);
    u.searchParams.set('from', peer.id);
    const share = u.toString();
    $('shareUrl').value = share;
    $('btnCopy').disabled = false;
    log('Comparte esta URL con el receptor. No cierres este navegador hasta finalizar ‚úÖ');
    setState('Esperando que el receptor se conecte‚Ä¶');
    // Aviso visible:
    alert('¬°URL lista! P√©gala en el navegador receptor. Mant√©n esta pesta√±a abierta hasta que la barra marque 100%.');
  }

  function connectTo(remoteId){
    if (!peer || peer.disconnected) { log('Inicializa el Peer primero.', 'warn'); return; }
    isSender = false;
    $('role').innerText = 'Receptor';
    $('remoteId').innerText = remoteId;
    log(`Conectando con ${remoteId}‚Ä¶`);
    conn = peer.connect(remoteId, { reliable: true, serialization: 'binary' });
    setupDataConnHandlers(conn);
  }

  function setupDataConnHandlers(c){
    c.on('open', () => {
      log('DataChannel abierto.');
      setState(isSender ? 'Listo para enviar' : 'Esperando datos‚Ä¶');

      // Diagn√≥stico: intentar enganchar estados ICE si es accesible
      try {
        const pc = c._pc || c.peerConnection || c.provider?.connections?.[c.peer]?.[0]?._pc;
        if (pc) {
          log(`ICE connection state: ${pc.iceConnectionState}`);
          pc.addEventListener('iceconnectionstatechange', () => {
            log(`ICE state ‚Üí ${pc.iceConnectionState}`);
          });
          pc.addEventListener('connectionstatechange', () => {
            log(`PeerConn state ‚Üí ${pc.connectionState}`);
          });
        } else {
          log('PeerConnection interno no accesible para diagn√≥stico fino (ok).');
        }
      } catch (e) { /* opcional */ }
    });

    c.on('data', handleIncomingData);
    c.on('error', (e) => { log('Conn error: ' + e.message, 'err'); setState('Error'); });
    c.on('close', () => { log('Conexi√≥n cerrada.'); if (!isSender) finalizeReceive(); });
  }

  /*** Env√≠o en chunks con backpressure ***/
  const CHUNK = 16 * 1024; // 16KB seguro para DataChannels
  let sendOffset = 0;
  let sendTimer = null;

  function startSend(){
    if (!conn || conn.open !== true) { log('No hay conexi√≥n abierta con receptor.', 'warn'); return; }
    if (!selectedFile) { log('Selecciona un fichero.', 'warn'); return; }

    // Enviar metadatos primero
    const meta = {
      type: 'meta',
      name: selectedFile.name,
      size: selectedFile.size,
      mime: selectedFile.type || 'application/octet-stream'
    };
    conn.send(meta);
    log(`Metadatos enviados: ${meta.name} (${human(meta.size)})`);

    // Enviar datos por partes con control de buffer
    sendOffset = 0;
    setBar(0, selectedFile.size);
    setState('Enviando‚Ä¶');
    window.onbeforeunload = () => 'La transferencia no ha terminado. ¬øSeguro que quieres salir?';

    const pump = () => {
      try {
        while (conn.open && sendOffset < selectedFile.size) {
          if (conn.bufferSize > 2 * 1024 * 1024) { // ~2MB en buffer ‚Üí pausa
            break;
          }
          const chunk = selectedFile.slice(sendOffset, sendOffset + CHUNK);
          sendOffset += CHUNK;
          chunk.arrayBuffer().then(buf => conn.send(buf));
          setBar(Math.min(sendOffset, selectedFile.size), selectedFile.size);
        }
        if (sendOffset >= selectedFile.size) {
          // Se√±al de fin
          conn.send({ type: 'eof' });
          setBar(selectedFile.size, selectedFile.size);
          setState('Finalizado (esperando confirmaci√≥n receptor)‚Ä¶');
          log('Env√≠o completo. Esperando confirmaci√≥n‚Ä¶');
          clearInterval(sendTimer);
          sendTimer = null;
        }
      } catch (e) {
        log('Error durante el env√≠o: ' + e.message, 'err');
      }
    };

    if (sendTimer) clearInterval(sendTimer);
    sendTimer = setInterval(pump, 30);
    pump();
  }

  /*** Recepci√≥n ***/
  let recvMeta = null;
  let recvBuffers = [];
  let receivedBytes = 0;
  function handleIncomingData(d){
    if (d && d.type === 'meta') {
      recvMeta = d;
      recvBuffers = [];
      receivedBytes = 0;
      setBar(0, recvMeta.size);
      setState('Recibiendo‚Ä¶');
      log(`Recibiendo: ${recvMeta.name} (${human(recvMeta.size)})`);
      return;
    }
    if (d && d.type === 'eof') {
      log('Se√±al de fin recibida. Ensamblando fichero‚Ä¶');
      finalizeReceive();
      return;
    }
    // Asumimos ArrayBuffer
    if (d instanceof ArrayBuffer) {
      recvBuffers.push(d);
      receivedBytes += d.byteLength;
      setBar(receivedBytes, recvMeta ? recvMeta.size : receivedBytes);
    } else {
      // Por compatibilidad si llega Blob
      try {
        if (d instanceof Blob) {
          recvBuffers.push(d);
          receivedBytes += d.size;
          setBar(receivedBytes, recvMeta ? recvMeta.size : receivedBytes);
        }
      } catch {}
    }
  }

  function finalizeReceive(){
    try {
      if (!recvMeta) { log('No hay metadatos; nada que ensamblar.'); return; }
      const blob = new Blob(recvBuffers, { type: recvMeta.mime || 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = $('downloadLink');
      a.href = url;
      a.download = sanitizeFileName(recvMeta.name || 'archivo.bin');
      $('downloadBox').style.display = '';
      setState('¬°Recibido! Descarga disponible.');
      setBar(recvMeta.size, recvMeta.size);
      log('Recepci√≥n completada. Puedes cerrar el receptor si ya descargaste el archivo.', 'ok');
      window.onbeforeunload = null;
      // Enviar confirmaci√≥n al emisor para que pueda liberar aviso
      if (conn && conn.open) conn.send({ type: 'ack' });
    } catch (e) {
      log('Error al ensamblar/descargar: ' + e.message, 'err');
      setState('Error en ensamblado');
    } finally {
      // limpiar buffers para liberar memoria
      recvBuffers = [];
    }
  }

  // Sanitiza nombre de fichero
  function sanitizeFileName(name){
    return String(name || 'archivo.bin').replace(/[^\w\-. ]+/g,'_').slice(0,180);
  }

  // Recibir ACK en el emisor
  // Lo tratamos en handleIncomingData si llega como objeto
  const _origHandle = handleIncomingData;
  handleIncomingData = function(d){
    if (d && d.type === 'ack') {
      log('Receptor confirm√≥ la recepci√≥n ‚úÖ', 'ok');
      setState('Completado');
      window.onbeforeunload = null;
      alert('Transferencia completada. Ya puedes cerrar esta pesta√±a.');
      return;
    }
    _origHandle(d);
  };

  // Si el usuario ya tiene par√°metros de servidor en la URL, precargarlos
  (function hydrateFromURL(){
    const p = new URL(location.href).searchParams;
    if (p.get('host')) $('host').value = p.get('host');
    if (p.get('secure')) $('secure').value = p.get('secure');
    if (p.get('port')) $('port').value = p.get('port');
    if (p.get('path')) $('path').value = p.get('path');
    if (p.get('stun')) $('stun').value = p.get('stun');
    if (p.get('turnUrl')) $('turnUrl').value = p.get('turnUrl');
    if (p.get('turnUser')) $('turnUser').value = p.get('turnUser');
    if (p.get('turnPass')) $('turnPass').value = p.get('turnPass');
  })();

  // UX: Si el usuario pulsa Enter en inputs, no recargar p√°gina
  document.addEventListener('keydown', e => {
    if (e.key === 'Enter' && ['INPUT','SELECT'].includes(e.target.tagName)) e.preventDefault();
  });

  // Auto-inicializar si el usuario no cambia la config en 1s (comodidad)
  let autoTimer = setTimeout(() => { if (!$('peerId').innerText || $('peerId').innerText==='‚Äî') initPeer(); }, 1000);
})();
</script>
</body>
</html>
