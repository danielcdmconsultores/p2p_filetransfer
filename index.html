<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>File‑share ultra‑robusto (PeerJS + TURN)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{font-family:Arial,sans-serif;margin:0;padding:1rem;background:#f5f5f5}
  .card{background:#fff;padding:1.5rem;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1);max-width:720px;margin:auto}
  h1{font-size:1.6rem;margin:0 0 .5rem}
  #info{font-size:.9rem;background:#fafafa;border:1px solid #ddd;padding:.5rem;margin-top:.5rem;border-radius:4px}
  #statusBar{margin-top:1rem;height:1.2rem;background:#e0e0e0;border-radius:4px;overflow:hidden}
  #statusBar div{height:100%;width:0;background:#4caf50;transition:width .2s}
  #link{word-break:break-all;color:#0066cc}
  button{background:#0066ff;color:#fff;border:none;padding:.5rem 1rem;border-radius:4px;cursor:pointer;margin-right:.4rem}
  button:disabled{background:#999;cursor:not-allowed}
  #msg{margin-top:.8rem;padding:.5rem;background:#fffae6;border-left:4px solid #ffeb3b}
  #langToggle{position:fixed;top:1rem;right:1rem;background:#eee;color:#333;padding:.3rem .6rem;border-radius:4px;cursor:pointer}
</style>
</head>
<body>

<div id="langToggle">🇪🇸 / 🇬🇧</div>

<div class="card">
  <h1 id="title">🔗 Compartir archivo / Share file</h1>

  <!-- ------------ EMISOR ------------ -->
  <div id="sender">
    <input type="file" id="fileInput">
    <p id="shareLink" style="display:none;">
      <span id="shareText">Copia y pega esta URL en el navegador del receptor</span>:
      <br><span id="link"></span>
      <button id="copyBtn">📋 Copy / Copiar</button>
    </p>
    <div id="msg"></div>
  </div>

  <!-- ------------ RECEPTOR ------------ -->
  <div id="receiver" style="display:none;">
    <p><b id="recvLabel">Receiving:</b> <span id="recvName"></span></p>
    <a id="downloadBtn" style="display:none;" download>⬇️ Download / Descargar</a>
    <div id="msg"></div>
  </div>

  <!-- ------------ PROGRESS ------------ -->
  <div id="statusBar"><div></div></div>

  <!-- ------------ DEBUG PANEL ------------ -->
  <div id="info">
    <strong>🔎 Debug info</strong><br>
    <b>Peer ID:</b> <span id="myId">‑</span><br>
    <b>Remote ID:</b> <span id="remoteId">‑</span><br>
    <b>Server used:</b> <span id="serverUsed">‑</span><br>
    <b>Attempt #:</b> <span id="attemptNum">0</span><br>
    <b>Conn. state:</b> <span id="connState">‑</span><br>
    <b>RTT (ping):</b> <span id="rtt">‑</span> ms<br>
    <b>Chunk #:</b> <span id="chunkNum">‑</span><br>
    <b>Chunk size:</b> <span id="chunkSize">64 KB</span>
  </div>
</div>

<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
(() => {
  /* ==================== 0️⃣ TEXTOS MULTILINGÜE ==================== */
  const LANG = {
    es:{title:'🔗 Compartir archivo',shareText:'Copia y pega esta URL en el navegador del receptor',copy:'📋 Copiar',copied:'✅ Copiado',waiting:'⏳ Esperando conexión…',connected:'✅ Conexión establecida',sending:'📤 Enviando archivo…',receiving:'📥 Recibiendo archivo…',download:'⬇️ Descargar',recv:'Recibiendo:',finished:'✅ Transferencia completada',dontClose:'⚠️ No cierres la ventana hasta que la descarga termine',error:'❗ Error: ',retrying:'🔄 Reintentando…',allFailed:'❌ No se pudo conectar con ningún servidor de señalización. Comprueba tu red.'},
    en:{title:'🔗 Share file',shareText:'Copy & paste this URL into the receiver’s browser',copy:'📋 Copy',copied:'✅ Copied',waiting:'⏳ Waiting for connection…',connected:'✅ Connected',sending:'📤 Sending file…',receiving:'📥 Receiving file…',download:'⬇️ Download',recv:'Receiving:',finished:'✅ Transfer complete',dontClose:'⚠️ Do not close the window until the download finishes',error:'❗ Error: ',retrying:'🔄 Retrying…',allFailed:'❌ Could not connect to any signalling server. Check your network.'}
  };
  let curLang='es';
  const t=()=>LANG[curLang];
  const setLang=l=>{curLang=l;document.getElementById('title').textContent=t().title;document.querySelector('#shareText').textContent=t().shareText;document.getElementById('copyBtn').textContent=t().copy;document.getElementById('recvLabel').textContent=t().recv;document.getElementById('downloadBtn').textContent=t().download;};
  setLang(curLang);
  document.getElementById('langToggle').onclick=()=>setLang(curLang==='es'?'en':'es');

  /* ==================== 1️⃣ UI HELPERS ==================== */
  const ui = {
    fileInput:   document.getElementById('fileInput'),
    shareLink:   document.getElementById('shareLink'),
    linkSpan:    document.getElementById('link'),
    copyBtn:     document.getElementById('copyBtn'),
    sender:      document.getElementById('sender'),
    receiver:    document.getElementById('receiver'),
    recvName:    document.getElementById('recvName'),
    downloadBtn: document.getElementById('downloadBtn'),
    statusBar:   document.getElementById('statusBar').firstElementChild,
    msgArea:     document.querySelectorAll('#msg'),
    info: {
      myId:      document.getElementById('myId'),
      remoteId:  document.getElementById('remoteId'),
      server:    document.getElementById('serverUsed'),
      attempts:  document.getElementById('attemptNum'),
      conn:      document.getElementById('connState'),
      rtt:       document.getElementById('rtt'),
      chunkNum:  document.getElementById('chunkNum'),
      chunkSize: document.getElementById('chunkSize')
    }
  };
  const setMsg = m=>ui.msgArea.forEach(e=>e.textContent=m);
  const setInfo = (k,v)=>ui.info[k].textContent=v;
  const updateProgress = r=>{const p=Math.min(100,Math.round(r*100));ui.statusBar.style.width=p+'%';if(p===100)ui.statusBar.style.background='#2196F3';};

  /* ==================== 2️⃣ SERVIDORES DE SEÑALIZACIÓN + ICE ==================== */
  const SIGNAL_SERVERS = [
    {host:'0.peerjs.com', secure:true, port:443},
    {host:'peerjs.com',    secure:true, port:443},
    {host:'peerjs-server.herokuapp.com', secure:true, port:443},
    {host:'peerjscloud.com', secure:true, port:443}
  ];

  // STUN + TURN público (OpenRelay)
  const ICE_SERVERS = [
    {urls:'stun:stun.l.google.com:19302'},
    {urls:'turn:openrelay.metered.ca:80', username:'openrelayproject', credential:'openrelayproject'}
  ];

  const SERVER_TIMEOUT = 8000;                // ms, para crear el Peer
  const MAX_RECONNECT_ATTEMPTS = 3;           // al perder la conexión
  const CHUNK_SIZE = 64*1024;                 // 64 KB

  let peer = null;
  let conn = null;
  let isSender = false;
  let fileMeta = null;
  let fileReader = null;
  let sending = false;
  let sendSeq = 0, ackedSeq = -1;
  let resendTimer = null;
  const RESEND_TIMEOUT = 5000;
  let reconnectAttempts = 0;
  let pingTimer = null;

  /* ==================== 3️⃣ CREAR PEER CON TIMEOUT ==================== */
  const startPeer = (srvIdx, onReady) => {
    if (srvIdx >= SIGNAL_SERVERS.length){
      setMsg(t().allFailed);
      return;
    }
    const srv = SIGNAL_SERVERS[srvIdx];
    setInfo('server',srv.host);
    setInfo('attempts',srvIdx+1);
    try{
      const p = new Peer(null,{host:srv.host,secure:srv.secure,port:srv.port,config:{iceServers:ICE_SERVERS}});
      const timeout = setTimeout(()=>{
        console.warn('Timeout opening Peer on',srv.host);
        p.destroy();
        startPeer(srvIdx+1,onReady);
      },SERVER_TIMEOUT);
      p.on('open', id => {
        clearTimeout(timeout);
        peer = p;
        setInfo('myId',id);
        console.log('Peer ready on',srv.host,'id',id);
        onReady();
      });
      p.on('error', err => {
        clearTimeout(timeout);
        console.warn('Peer error on',srv.host,err);
        p.destroy();
        startPeer(srvIdx+1,onReady);
      });
    }catch(e){
      console.error('Exception creating Peer',e);
      startPeer(srvIdx+1,onReady);
    }
  };

  /* ==================== 4️⃣ PING / RTT ==================== */
  const startPing = (c) => {
    if (pingTimer) clearInterval(pingTimer);
    pingTimer = setInterval(()=>{
      const ts = Date.now();
      c.send({type:'ping',ts});
      c.once('data',msg=>{
        if (msg.type==='pong' && msg.ts===ts){
          setInfo('rtt', Date.now()-ts);
        }
      });
    },3000);
  };

  /* ==================== 5️⃣ EMISOR ==================== */
  ui.fileInput.addEventListener('change',()=>{
    const f = ui.fileInput.files[0];
    if (!f) return;
    fileMeta = {name:f.name,size:f.size,type:f.type};
    const url = `${location.origin}${location.pathname}?peer=${peer.id}`;
    ui.linkSpan.textContent = url;
    ui.shareLink.style.display='block';
    setMsg(t().waiting);
    isSender = true;
  });

  ui.copyBtn.addEventListener('click',async()=>{
    try{
      await navigator.clipboard.writeText(ui.linkSpan.textContent);
      ui.copyBtn.textContent = t().copied;
      setTimeout(()=>ui.copyBtn.textContent=t().copy,1500);
    }catch(e){ console.error('clipboard error',e); }
  });

  const handleIncoming = c => {
    conn = c;
    setInfo('remoteId',c.peer);
    setInfo('conn','open');
    setMsg(t().connected);
    startPing(c);
    c.on('data',msg=>{ if (msg.type==='ack') processAck(msg); });
    c.on('close',()=>{ setInfo('conn','closed'); tryReconnect(); });
    c.on('error',e=>{ setMsg(t().error+e); setInfo('conn','error'); tryReconnect(); });
    c.on('open',()=>{ startSending(c); });
  };

  const startSending = async c => {
    if (!fileMeta) return;
    sending = true;
    sendSeq = 0; ackedSeq = -1;
    setMsg(t().sending);
    c.send({type:'meta',data:fileMeta});
    updateProgress(0);
    fileReader = ui.fileInput.files[0].stream().getReader();
    sendNextChunk(c);
  };

  const sendNextChunk = async c => {
    if (sendSeq <= ackedSeq) sendSeq = ackedSeq + 1;
    const offset = sendSeq * CHUNK_SIZE;
    if (offset >= fileMeta.size) return;
    const {done, value} = await fileReader.read();
    if (done) return;
    c.send({type:'chunk',seq:sendSeq,data:value.buffer});
    setInfo('chunkNum',sendSeq);
    updateProgress((offset+value.byteLength)/fileMeta.size);
    clearTimeout(resendTimer);
    resendTimer = setTimeout(()=>{
      console.warn('No ACK for seq',sendSeq,'— retransmit');
      setMsg(t().retrying);
      // volver a leer el mismo bloque con slice
      fileReader.releaseLock();
      fileReader = ui.fileInput.files[0].slice(offset,offset+CHUNK_SIZE).stream().getReader();
      sendNextChunk(c);
    },RESEND_TIMEOUT);
    sendSeq++;
  };

  const processAck = msg => {
    ackedSeq = msg.seq;
    clearTimeout(resendTimer);
    if (ackedSeq === Math.ceil(fileMeta.size/CHUNK_SIZE)-1){
      setMsg(t().finished);
      sending = false;
      updateProgress(1);
      conn.send({type:'end'});
      return;
    }
    sendNextChunk(conn);
  };

  const tryReconnect = () => {
    if (!sending || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS){
      setMsg(t().error+'No se pudo restablecer la conexión.');
      return;
    }
    reconnectAttempts++;
    setMsg(t().retrying+` (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
    const currentSrvIdx = SIGNAL_SERVERS.findIndex(s=>s.host===ui.info.server.textContent);
    if (peer) peer.destroy();
    setTimeout(()=>startPeer(currentSrvIdx,()=>{ peer.on('connection',c=>handleIncoming(c)); }),2000);
  };

  /* ==================== 6️⃣ RECEPTOR ==================== */
  const urlParams = new URLSearchParams(location.search);
  const remoteId = urlParams.get('peer');

  if (remoteId){
    // modo receptor
    ui.sender.style.display='none';
    ui.receiver.style.display='block';
    setMsg(t().waiting);
    const onReady = () => {
      const c = peer.connect(remoteId);
      conn = c;
      setInfo('remoteId',remoteId);
      setInfo('conn','connecting');
      c.on('open',()=>{ setInfo('conn','open'); startPing(c); });
      c.on('error',e=>{ setMsg(t().error+e); setInfo('conn','error'); });
      c.on('close',()=>{ setInfo('conn','closed'); });
      let recvMeta = null;
      let received = [];
      let expectedSeq = 0;

      c.on('data',msg=>{
        if (msg.type==='meta'){
          recvMeta = msg.data;
          ui.recvName.textContent = recvMeta.name;
          setMsg(t().receiving);
          updateProgress(0);
          expectedSeq = 0; received = [];
          c.send({type:'ack',seq:-1});
        }else if (msg.type==='chunk'){
          if (msg.seq!==expectedSeq){
            console.warn('Chunk out of order',msg.seq,'expected',expectedSeq);
            c.send({type:'ack',seq:expectedSeq-1});
            return;
          }
          received.push(new Uint8Array(msg.data));
          setInfo('chunkNum',msg.seq);
          updateProgress(((msg.seq+1)*CHUNK_SIZE)/recvMeta.size);
          c.send({type:'ack',seq:msg.seq});
          expectedSeq++;
        }else if (msg.type==='end'){
          const blob = new Blob(received,{type:recvMeta.type});
          const dl = URL.createObjectURL(blob);
          ui.downloadBtn.href = dl;
          ui.downloadBtn.download = recvMeta.name;
          ui.downloadBtn.style.display = 'inline-block';
          setMsg(t().finished);
          updateProgress(1);
          ui.downloadBtn.onclick = () => { downloadFinished = true; setTimeout(()=>URL.revokeObjectURL(dl),30000); };
        }else if (msg.type==='ping'){
          c.send({type:'pong',ts:msg.ts});
        }
      });
    };
    startPeer(0,onReady);
  }

  /* ==================== 7️⃣ PREVENCIÓN DE CIERRE ==================== */
  let downloadFinished = false;
  window.addEventListener('beforeunload',e=>{
    if (!downloadFinished){
      e.preventDefault(); e.returnValue = t().dontClose; return t().dontClose;
    }
  });

  /* ==================== 8️⃣ ERRORES GLOBALES ==================== */
  window.addEventListener('error',e=>{
    console.error('Global error',e.error);
    setMsg(t().error+e.message);
  });
})();
</script>
</body>
</html>
