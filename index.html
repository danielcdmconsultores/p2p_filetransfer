<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Transferencia de ficheros con PeerJS (WebRTC)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{font-family:Arial,sans-serif;margin:0;padding:1rem;background:#f5f5f5}
  .card{background:#fff;padding:1.5rem;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1);max-width:600px;margin:auto}
  h1{font-size:1.6rem;margin:0 0 .5rem}
  #status{margin-top:1rem;height:1.2rem;background:#e0e0e0;border-radius:4px;overflow:hidden}
  #status div{height:100%;width:0;background:#4caf50;transition:width .3s}
  #link{word-break:break-all;color:#0066cc}
  input[type=file]{display:block;margin:1rem 0}
  button{background:#0066ff;color:#fff;border:none;padding:.5rem 1rem;border-radius:4px;cursor:pointer}
  button:disabled{background:#999;cursor:not-allowed}
</style>
</head>
<body>
<div class="card">
  <h1>üîó Compartir archivo (PeerJS)</h1>

  <!-- 1Ô∏è‚É£ Parte ‚Äúemisor‚Äù -->
  <div id="sender">
    <input type="file" id="fileInput">
    <p id="shareLink" style="display:none;">
      Copia y pega esta URL en el navegador del receptor:
      <span id="link"></span>
    </p>
  </div>

  <!-- 2Ô∏è‚É£ Parte ‚Äúreceptor‚Äù (se muestra s√≥lo cuando llega una conexi√≥n) -->
  <div id="receiver" style="display:none;">
    <p id="recvInfo">Recibiendo: <b id="recvName"></b></p>
    <a id="downloadBtn" style="display:none;" download>‚¨áÔ∏è Descargar archivo</a>
  </div>

  <!-- 3Ô∏è‚É£ Barra de estado (progreso) -->
  <div id="status"><div></div></div>
</div>

<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
(() => {
  // ---------- CONFIGURACI√ìN SEGURA ----------
  //   ‚Ä¢ Usamos HTTPS (el script de PeerJS se sirve v√≠a CDN seguro)
  //   ‚Ä¢ Conexi√≥n al servidor p√∫blico de PeerJS (TLS, puerto 443)
  //   ‚Ä¢ No guardamos nada en localStorage ni ejecutamos c√≥digo arbitrario.
  const peer = new Peer(null, {
    host: '0.peerjs.com',
    secure: true,
    port: 443
  });

  const fileInput   = document.getElementById('fileInput');
  const shareLink   = document.getElementById('shareLink');
  const linkSpan    = document.getElementById('link');
  const statusBar   = document.getElementById('status').firstElementChild;
  const receiverDiv = document.getElementById('receiver');
  const recvInfo    = document.getElementById('recvInfo');
  const recvName    = document.getElementById('recvName');
  const downloadBtn = document.getElementById('downloadBtn');

  // ---------- ESTADO ----------
  const CHUNK_SIZE = 64 * 1024;           // 64‚ÄØKB (tama√±o razonable para data‚Äëchannels)
  let fileMeta = null;                    // {name,size,type}
  let chunks   = [];                      // almacena los blobs recibidos

  // ---------- EMISOR ----------
  peer.on('open', id => {
    // Cuando el peer est√° listo, el usuario podr√° elegir un fichero.
    console.log('Peer inicializado con id:', id);
  });

  // Cuando el usuario escoge un archivo‚Ä¶
  fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (!file) return;

    fileMeta = {name: file.name, size: file.size, type: file.type};

    // Generamos la URL que el otro navegador debe abrir.
    const url = `${location.origin}${location.pathname}?peer=${peer.id}`;
    linkSpan.textContent = url;
    shareLink.style.display = 'block';

    // Esperamos la conexi√≥n del receptor.
    peer.on('connection', conn => {
      console.log('Conexi√≥n entrante:', conn.peer);
      conn.on('open', () => sendFile(conn, file));
      conn.on('error', err => console.error('Error de conexi√≥n:', err));
    });
  });

  // Env√≠o del fichero en trozos.
  async function sendFile(conn, file) {
    // 1Ô∏è‚É£ Enviamos primero los metadatos (nombre, tama√±o, tipo)
    conn.send({type:'meta', data:fileMeta});
    updateProgress(0);

    // 2Ô∏è‚É£ Leemos el archivo en bloques y los enviamos uno a uno.
    const fileReader = file.stream().getReader();
    let offset = 0;

    while (true) {
      const {done, value} = await fileReader.read();
      if (done) break;                 // fin del stream

      // value es un Uint8Array ‚Üí lo convertimos en Blob para enviarlo
      conn.send({type:'chunk', data: value.buffer});   // ArrayBuffer es transferible
      offset += value.byteLength;
      updateProgress(offset / fileMeta.size);
    }

    // 3Ô∏è‚É£ Se√±al de fin de transmisi√≥n
    conn.send({type:'end'});
    console.log('Archivo enviado completamente');
  }

  // ---------- RECEPTOR ----------
  // Si la URL contiene ?peer=xxxx, nos convertimos en receptor.
  const urlParams = new URLSearchParams(location.search);
  const remoteId = urlParams.get('peer');
  if (remoteId) {
    // Ocultamos la zona de env√≠o y activamos la de recepci√≥n.
    document.getElementById('sender').style.display = 'none';
    receiverDiv.style.display = 'block';

    // Creamos una conexi√≥n saliente al peer que est√° enviando.
    const conn = peer.connect(remoteId);
    conn.on('open', () => console.log('Conexi√≥n establecida con', remoteId));
    conn.on('data', handleIncoming);
    conn.on('error', err => console.error('Error de conexi√≥n:', err));
  }

  // Maneja los mensajes que llegan del emisor.
  function handleIncoming(msg) {
    if (msg.type === 'meta') {
      // 1Ô∏è‚É£ Recibimos los metadatos.
      fileMeta = msg.data;
      recvName.textContent = fileMeta.name;
      updateProgress(0);
    } else if (msg.type === 'chunk') {
      // 2Ô∏è‚É£ Cada bloque llega como ArrayBuffer ‚Üí lo guardamos.
      chunks.push(new Uint8Array(msg.data));
      const received = chunks.reduce((s, c) => s + c.byteLength, 0);
      updateProgress(received / fileMeta.size);
    } else if (msg.type === 'end') {
      // 3Ô∏è‚É£ Todo recibido ‚Üí ensamblamos el Blob y generamos el enlace de descarga.
      const blob = new Blob(chunks, {type: fileMeta.type});
      const url = URL.createObjectURL(blob);
      downloadBtn.href = url;
      downloadBtn.download = fileMeta.name;
      downloadBtn.textContent = `‚¨áÔ∏è Descargar "${fileMeta.name}" (${(fileMeta.size/1024/1024).toFixed(2)}‚ÄØMiB)`;
      downloadBtn.style.display = 'inline-block';
      updateProgress(1);
      console.log('Transferencia completada');
    }
  }

  // ---------- UI ----------
  function updateProgress(ratio) {
    const pct = Math.min(100, Math.round(ratio * 100));
    statusBar.style.width = pct + '%';
    if (pct === 100) {
      statusBar.style.background = '#2196F3';
    }
  }

  // ---------- FALLBACK Y SEGURIDAD ----------
  // Cualquier excepci√≥n inesperada se captura y muestra en consola (no se expone al usuario).
  window.addEventListener('error', e => console.error('Error global:', e.error));
})();
</script>
</body>
</html>
