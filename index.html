<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>P2P_FileTransfer - Mejorado con reanudación y opción relay</title>
  <style>
    body{font-family:sans-serif;background:#eef;padding:1rem}
    .pill{display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#eef;color:#223;font-size:.8rem;margin-left:.5rem}
    .status{margin-top:1rem;padding:.5rem;border-radius:6px}
    .status.success{background:#e6fffa;border:1px solid #0aa;color:#055}
    .status.error{background:#ffe6ef;border:1px solid #d33;color:#933}
  </style>
</head>
<body>
  <h1>P2P_FileTransfer (mejorado)</h1>
  <input type="file" id="fileInput" />
  <button id="generateLinkBtn" disabled>Generar enlace</button>
  <div id="linkBox"></div>
  <div class="status" id="status"></div>
  <progress id="progress" value="0" max="100" style="width:100%;display:none"></progress>
  <button id="downloadBtn" disabled>Descargar</button>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
const ICE_SERVERS = [
  {urls:["stun:stun.l.google.com:19302"]},
  {urls:["turn:openrelay.metered.ca:80","turn:openrelay.metered.ca:443","turn:openrelay.metered.ca:443?transport=tcp"],username:"openrelayproject",credential:"openrelayproject"}
];

const urlParams=new URLSearchParams(location.search);
const FORCE_RELAY=urlParams.get("relay")==="1";
const PEER_OPTIONS={config:{iceServers:ICE_SERVERS,iceTransportPolicy:FORCE_RELAY?"relay":"all"}};

const fileInput=document.getElementById("fileInput");
const generateLinkBtn=document.getElementById("generateLinkBtn");
const linkBox=document.getElementById("linkBox");
const status=document.getElementById("status");
const progress=document.getElementById("progress");
const downloadBtn=document.getElementById("downloadBtn");

let selectedFile=null;
let peer,connection,encryptionKey;
let sentBytes=0,receivedBytes=0,fileMeta=null,chunks=[];

fileInput.addEventListener("change",()=>{
  if(fileInput.files[0]){selectedFile=fileInput.files[0];generateLinkBtn.disabled=false;}
});

generateLinkBtn.addEventListener("click",async()=>{
  const channelId=crypto.randomUUID();
  encryptionKey=await crypto.subtle.generateKey({name:"AES-GCM",length:256},true,["encrypt","decrypt"]);
  const raw=new Uint8Array(await crypto.subtle.exportKey("raw",encryptionKey));
  const keyB64=btoa(String.fromCharCode(...raw));
  const link=`${location.origin}${location.pathname}?relay=${FORCE_RELAY?1:0}#${channelId}:${keyB64}`;
  linkBox.textContent=link;

  peer=new Peer(channelId,PEER_OPTIONS);
  peer.on("connection",conn=>{
    connection=conn;
    connection.on("open",()=>{
      status.textContent="Receptor conectado";
      // mandar metadatos
      connection.send(JSON.stringify({type:"metadata",name:selectedFile.name,size:selectedFile.size,mime:selectedFile.type}));
    });
    connection.on("data",msg=>handleReceiverAck(msg));
  });
});

function handleReceiverAck(msg){
  if(msg instanceof ArrayBuffer){return;}
  try{msg=JSON.parse(msg);}catch{}
  if(msg.type==="ack"&&msg.offset!==undefined){
    sentBytes=msg.offset;
    status.textContent=`Reanudando desde ${sentBytes}`;
    sendChunks();
  }
}

async function sendChunks(){
  const reader=selectedFile.stream().getReader();
  let offset=0;
  while(true){
    const {value,done}=await reader.read();
    if(done)break;
    for(let i=0;i<value.length;i+=64*1024){
      const slice=value.subarray(i,i+64*1024);
      if(offset+slice.length<=sentBytes){offset+=slice.length;continue;}
      const iv=crypto.getRandomValues(new Uint8Array(12));
      const enc=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},encryptionKey,slice));
      connection.send(enc.buffer);
      connection.send(JSON.stringify({type:"iv",iv:Array.from(iv)}));
      offset+=slice.length;sentBytes=offset;
      const p=(offset/selectedFile.size)*100;
      progress.style.display="block";progress.value=p;
    }
  }
  status.textContent="Archivo enviado";
}

// === receptor ===
if(location.hash){
  const [channelId,keyB64]=location.hash.substring(1).split(":");
  const raw=Uint8Array.from(atob(keyB64),c=>c.charCodeAt(0));
  crypto.subtle.importKey("raw",raw,{name:"AES-GCM"},false,["decrypt"]).then(key=>{
    encryptionKey=key;
    peer=new Peer(undefined,PEER_OPTIONS);
    peer.on("open",id=>{
      connection=peer.connect(channelId,{reliable:true});
      connection.on("open",()=>{
        status.textContent="Conectado al emisor, esperando metadata";
      });
      connection.on("data",async data=>{
        if(typeof data==="string"){try{const msg=JSON.parse(data);
          if(msg.type==="metadata"){fileMeta=msg;receivedBytes=0;chunks=[];connection.send(JSON.stringify({type:"ack",offset:0}));progress.max=100;}
          if(msg.type==="iv"){currentIV=new Uint8Array(msg.iv);} }catch{}}
        else if(data instanceof ArrayBuffer){
          try{const dec=await crypto.subtle.decrypt({name:"AES-GCM",iv:currentIV},encryptionKey,data);
            chunks.push(dec);receivedBytes+=dec.byteLength;
            progress.style.display="block";progress.value=(receivedBytes/fileMeta.size)*100;
            if(receivedBytes>=fileMeta.size){
              status.textContent="Archivo recibido";
              const blob=new Blob(chunks,{type:fileMeta.mime});
              downloadBtn.disabled=false;
              downloadBtn.onclick=()=>{
                const url=URL.createObjectURL(blob);
                const a=document.createElement("a");a.href=url;a.download=fileMeta.name;a.click();URL.revokeObjectURL(url);
              };
            }
          }catch(e){status.textContent="Error descifrando";}
        }
      });
    });
  });
}
</script>
</body>
</html>
