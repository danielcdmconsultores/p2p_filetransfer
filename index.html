<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>P2P_FileTransfer - Transferencia segura de archivos by Daniel Pe√±a Silva (mejorado)</title>
  <meta name="description" content="Transferencia segura de archivos P2P entre navegadores usando WebRTC. Incluye fallback a TURN p√∫blico y control de backpressure." />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='55%' x='10%' font-size='80'>üîí</text></svg>">
  <style>
    :root {
      --primary-color: #4361ee;
      --secondary-color: #3a0ca3;
      --accent-color: #7209b7;
      --light-color: #f8f9fa;
      --dark-color: #212529;
      --success-color: #4cc9f0;
      --warning-color: #f72585;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: var(--dark-color); background: linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 1000px; margin: 0 auto; background: #fff; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,.1); overflow: hidden; }
    header { background: linear-gradient(to right, var(--primary-color), var(--secondary-color)); color: #fff; padding: 2rem; text-align: center; }
    h1 { font-size: 2.5rem; margin-bottom: .5rem; }
    .subtitle { font-size: 1.05rem; opacity: .92; }
    .main-content { display: flex; flex-direction: column; padding: 2rem; }
    @media (min-width: 768px) { .main-content { flex-direction: row; } }
    .sender-section, .receiver-section { flex: 1; padding: 1.5rem; }
    .divider { width: 100%; height: 1px; background: #eee; margin: 1.5rem 0; }
    @media (min-width: 768px) { .divider { width: 1px; height: auto; margin: 0 1.5rem; } }
    .section-title { font-size: 1.5rem; margin-bottom: 1.5rem; color: var(--secondary-color); display: flex; align-items: center; }
    .section-title svg { margin-right: 10px; }
    .file-drop-area { border: 2px dashed #ccc; border-radius: 8px; padding: 2rem; text-align: center; transition: all .3s; margin-bottom: 1.5rem; cursor: pointer; }
    .file-drop-area:hover, .file-drop-area.active { border-color: var(--primary-color); background: rgba(67,97,238,.05); }
    .file-input { display: none; }
    .file-info { margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; display: none; }
    .btn { display: inline-block; padding: .8rem 1.5rem; background: var(--primary-color); color: #fff; border: none; border-radius: 50px; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all .3s; text-align: center; margin-top: 1rem; }
    .btn:hover { background: var(--secondary-color); transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,.1); }
    .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
    .btn-warning { background: var(--warning-color); }
    .btn-warning:hover { background: #d81159; }
    .share-link { margin-top: 1.5rem; display: none; }
    .link-box { display: flex; margin-top: .5rem; }
    .link-input { flex: 1; padding: .8rem; border: 1px solid #ddd; border-radius: 4px 0 0 4px; font-size: .9rem; }
    .copy-btn { padding: .8rem 1.2rem; background: var(--accent-color); color: #fff; border: none; border-radius: 0 4px 4px 0; cursor: pointer; }
    .progress-container { margin-top: 1.5rem; display: none; }
    .progress-bar { height: 10px; background: #f0f0f0; border-radius: 5px; overflow: hidden; }
    .progress { height: 100%; background: linear-gradient(to right, var(--primary-color), var(--accent-color)); width: 0%; transition: width .3s; }
    .transfer-stats { display: flex; justify-content: space-between; margin-top: .5rem; font-size: .9rem; color: #666; }
    .status { margin-top: 1rem; padding: 1rem; border-radius: 8px; display: none; }
    .status.success { background: rgba(76,201,240,.1); border: 1px solid var(--success-color); color: #0a6c74; }
    .status.error { background: rgba(247,37,133,.1); border: 1px solid var(--warning-color); color: #a4133c; }
    .receiver-ui { display: none; }
    footer { text-align: center; padding: 1.5rem; background: #f8f9fa; color: #6c757d; font-size: .9rem; }
    .security-badge { display: inline-flex; align-items: center; background: rgba(76,201,240,.1); color: #0a6c74; padding: .5rem 1rem; border-radius: 50px; margin-top: 1rem; font-weight: 600; }
    .security-badge svg { margin-right: 5px; }
    .transfer-info { margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; display: none; }
    .speedometer { display: flex; align-items: center; justify-content: space-around; margin-top: 1rem; }
    .speed-value { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
    .speed-label { font-size: .9rem; color: #666; }
    .pill { display:inline-block; padding:.25rem .6rem; border-radius:999px; background:#eef; color:#223; font-size:.8rem; margin-left:.5rem }
  </style>
</head>
<body>
<main class="container" role="main" aria-label="Transferencia de archivos P2P">
  <header role="banner">
    <h1 tabindex="0">P2P_FileTransfer</h1>
    <p class="subtitle" aria-label="Descripci√≥n">Transferencia segura de archivos entre dispositivos P2P sin servidor ‚Äì by Daniel Pe√±a Silva</p>
  </header>

  <section class="main-content" aria-label="Panel principal">
    <section class="sender-section" aria-label="Enviar archivo">
      <h2 class="section-title" tabindex="0">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
        Enviar archivo <span id="connTypeSender" class="pill" title="Tipo de ruta ICE (directa/relay)">ICE: --</span>
      </h2>

      <div class="file-drop-area" id="dropArea" tabindex="0" aria-label="√Årea para arrastrar o seleccionar archivo">
        <p>Haga clic o arrastre un archivo aqu√≠</p>
        <p class="small">(El tama√±o m√°ximo depende de su navegador)</p>
        <input type="file" id="fileInput" class="file-input" aria-label="Seleccionar archivo" />
      </div>

      <div class="file-info" id="fileInfo">
        <p><strong>Archivo:</strong> <span id="fileName"></span></p>
        <p><strong>Tama√±o:</strong> <span id="fileSize"></span></p>
      </div>

      <button id="generateLinkBtn" class="btn" disabled aria-disabled="true">Generar enlace seguro</button>

      <div class="share-link" id="shareLink" aria-live="polite">
        <p>Comparte este enlace con el destinatario:</p>
        <div class="link-box">
          <input type="text" id="linkInput" class="link-input" readonly aria-label="Enlace seguro generado" />
          <button id="copyLinkBtn" class="copy-btn" aria-label="Copiar enlace al portapapeles">Copiar</button>
        </div>
        <p class="security-badge">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
          Conexi√≥n segura P2P
        </p>
      </div>

      <div class="progress-container" id="progressContainer" aria-live="polite">
        <p>Transferencia en progreso:</p>
        <div class="progress-bar"><div class="progress" id="progressBar"></div></div>
        <div class="transfer-stats">
          <span id="progressText">0%</span>
          <span id="transferredSize">0 B / 0 B</span>
        </div>
      </div>

      <div class="transfer-info" id="transferInfo" aria-live="polite">
        <div class="speedometer">
          <div><div class="speed-value" id="speedValue">0 KB/s</div><div class="speed-label">Velocidad</div></div>
          <div><div class="speed-value" id="timeLeft">--:--</div><div class="speed-label">Tiempo restante</div></div>
        </div>
      </div>

      <div class="status" id="statusMessage" role="status" aria-live="assertive"></div>
    </section>

    <div class="divider" aria-hidden="true"></div>

    <section class="receiver-section" aria-label="Recibir archivo">
      <h2 class="section-title" tabindex="0">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
        Recibir archivo <span id="connTypeReceiver" class="pill" title="Tipo de ruta ICE (directa/relay)">ICE: --</span>
      </h2>

      <div class="receiver-ui" id="receiverUI" aria-live="polite">
        <p>Esperando archivo: <strong id="waitingFileName"></strong></p>
        <p>Tama√±o: <span id="waitingFileSize"></span></p>
        <div class="progress-container" id="receiverProgress">
          <p>Descargando:</p>
          <div class="progress-bar"><div class="progress" id="receiverProgressBar"></div></div>
          <div class="transfer-stats">
            <span id="receiverProgressText">0%</span>
            <span id="receiverTransferredSize">0 B / 0 B</span>
          </div>
        </div>
        <button id="downloadBtn" class="btn" disabled aria-disabled="true">Descargar archivo</button>
        <div class="status" id="receiverStatus" role="status" aria-live="assertive"></div>
      </div>

      <p id="receiverInstructions" aria-label="Instrucciones para recibir archivo">Para recibir un archivo, use el enlace proporcionado por el remitente.</p>
    </section>
  </section>

  <footer role="contentinfo">
    <p>SecureP2PTransfer ‚Äì Transferencia directa entre navegadores usando WebRTC.</p>
    <p>Los archivos nunca se almacenan en servidores externos. Si el emisor cierra el navegador, la transmisi√≥n se corta.</p>
  </footer>
</main>

<script>
  // ===== Config ICE: STUN + TURN p√∫blico (OpenRelay) =====
  // Fuente: OpenRelay (openrelay.metered.ca) proporciona TURN gratuito con l√≠mites.
  const ICE_SERVERS = [
    { urls: [
      'stun:stun.l.google.com:19302',
      'stun:stun1.l.google.com:19302',
      'stun:stun2.l.google.com:19302',
      'stun:stun3.l.google.com:19302',
      'stun:stun4.l.google.com:19302'
    ]},
    { urls: [
      'turn:openrelay.metered.ca:80',
      'turn:openrelay.metered.ca:443',
      'turn:openrelay.metered.ca:443?transport=tcp'
    ], username: 'openrelayproject', credential: 'openrelayproject' }
  ];

  // ===== Se√±alizaci√≥n PeerJS (usa el cloud por defecto) + ICE propio
  const PEER_OPTIONS = {
    // secure:true, host y path se autoconfiguran al cloud gratuito de PeerJS si no se indica.
    config: { iceServers: ICE_SERVERS, iceTransportPolicy: 'all' }
  };

  document.addEventListener('DOMContentLoaded', () => {
    /* Accesibilidad: manejo de foco c√≠clico */
    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    document.body.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        const focusables = Array.from(document.querySelectorAll(focusableElements)).filter(el => !el.disabled && el.offsetParent !== null);
        if (focusables.length) {
          const first = focusables[0];
          const last = focusables[focusables.length - 1];
          if (e.shiftKey && document.activeElement === first) { last.focus(); e.preventDefault(); }
          else if (!e.shiftKey && document.activeElement === last) { first.focus(); e.preventDefault(); }
        }
      }
    });

    // UI refs
    const dropArea = document.getElementById('dropArea');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const generateLinkBtn = document.getElementById('generateLinkBtn');
    const shareLink = document.getElementById('shareLink');
    const linkInput = document.getElementById('linkInput');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const transferredSize = document.getElementById('transferredSize');
    const transferInfo = document.getElementById('transferInfo');
    const speedValue = document.getElementById('speedValue');
    const timeLeft = document.getElementById('timeLeft');
    const statusMessage = document.getElementById('statusMessage');
    const receiverUI = document.getElementById('receiverUI');
    const receiverInstructions = document.getElementById('receiverInstructions');
    const waitingFileName = document.getElementById('waitingFileName');
    const waitingFileSize = document.getElementById('waitingFileSize');
    const receiverProgress = document.getElementById('receiverProgress');
    const receiverProgressBar = document.getElementById('receiverProgressBar');
    const receiverProgressText = document.getElementById('receiverProgressText');
    const receiverTransferredSize = document.getElementById('receiverTransferredSize');
    const downloadBtn = document.getElementById('downloadBtn');
    const receiverStatus = document.getElementById('receiverStatus');
    const connTypeSender = document.getElementById('connTypeSender');
    const connTypeReceiver = document.getElementById('connTypeReceiver');

    // State
    let selectedFile = null;
    let peer = null; // PeerJS Peer
    let connection = null; // DataConnection (PeerJS)
    let transferStartTime = null;
    let speedHistory = [];
    let encryptionKey = null; // CryptoKey (AES-GCM)

    // Drag & drop
    dropArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelect);
    dropArea.addEventListener('dragover', e => { e.preventDefault(); dropArea.classList.add('active'); });
    dropArea.addEventListener('dragleave', () => dropArea.classList.remove('active'));
    dropArea.addEventListener('drop', e => { e.preventDefault(); dropArea.classList.remove('active'); if (e.dataTransfer.files.length) { fileInput.files = e.dataTransfer.files; handleFileSelect(e); } });

    function handleFileSelect(e) {
      selectedFile = e.target.files?.[0] || e.dataTransfer?.files?.[0] || null;
      if (selectedFile) {
        fileName.textContent = selectedFile.name;
        fileSize.textContent = formatFileSize(selectedFile.size);
        fileInfo.style.display = 'block';
        generateLinkBtn.disabled = false;
        transferredSize.textContent = `0 B / ${formatFileSize(selectedFile.size)}`;
      }
    }

    // ===== Generar enlace seguro (clave se comparte en el hash) =====
    generateLinkBtn.addEventListener('click', async () => {
      if (!selectedFile) return;
      generateLinkBtn.disabled = true; statusMessage.style.display = 'none';
      const channelId = generateChannelId();

      // Generar clave AES-GCM (la IV ser√° por-chunk)
      const key = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
      encryptionKey = key;
      const raw = new Uint8Array(await crypto.subtle.exportKey('raw', key));
      const keyB64 = btoa(String.fromCharCode(...raw));

      const link = `${location.origin}${location.pathname}#${channelId}:${keyB64}`; // (Sin IV global)
      linkInput.value = link; shareLink.style.display = 'block';

      // Inicializar PeerJS (emisor) con TURN/STUN
      peer = new Peer(channelId, PEER_OPTIONS);
      attachPeerDiagnostics(peer, connTypeSender);

      peer.on('open', id => {
        peer.on('connection', conn => {
          connection = conn; setupDataChannelSender();
        });
      });
      peer.on('error', err => showStatus(statusMessage, `Error PeerJS: ${err.type || err.message}`, true));
    });

    // ===== Env√≠o: DataChannel con backpressure y cifrado =====
    function setupDataChannelSender() {
      const dc = connection;
      showStatus(statusMessage, 'Destinatario conectado. Preparando transferencia...', false, true);

      dc.on('open', () => {
        // Metadatos
        dc.send({ type: 'metadata', name: selectedFile.name, size: selectedFile.size, mimeType: selectedFile.type });
        // UI
        progressContainer.style.display = 'block'; transferInfo.style.display = 'block'; transferStartTime = Date.now();
        // Backpressure
        try { dc.bufferedAmountLowThreshold = 1 * 1024 * 1024; } catch (e) {}
        sendFileInChunks(dc, selectedFile, encryptionKey);
      });

      dc.on('close', () => showStatus(statusMessage, 'Conexi√≥n cerrada', false));
      dc.on('error', err => showStatus(statusMessage, `Error en la transferencia: ${err.message}`, true));
    }

    async function sendFileInChunks(dc, file, key) {
      const reader = file.stream().getReader(); // Menos GC que FileReader incremental
      const CHUNK_SIZE = 64 * 1024; // 64KB (mejor para menos overhead)
      let sentBytes = 0;

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        // trocear value (puede ser grande)
        for (let offset = 0; offset < value.length; offset += CHUNK_SIZE) {
          const slice = value.subarray(offset, Math.min(offset + CHUNK_SIZE, value.length));
          // Backpressure: esperar si el buffer est√° alto
          if (dc.bufferedAmount > 16 * 1024 * 1024) { // 16MB
            await waitBufferedAmountLow(dc);
          }
          // Cifrar con IV aleatoria por chunk
          const iv = crypto.getRandomValues(new Uint8Array(12));
          const encrypted = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, slice));
          dc.send({ type: 'chunk', iv: Array.from(iv), data: Array.from(encrypted) });
          sentBytes += slice.byteLength;
          // Progreso
          const progress = (sentBytes / file.size) * 100;
          progressBar.style.width = `${progress}%`;
          progressText.textContent = `${progress.toFixed(1)}%`;
          transferredSize.textContent = `${formatFileSize(sentBytes)} / ${formatFileSize(file.size)}`;
          // Velocidad y ETA
          const elapsed = (Date.now() - transferStartTime) / 1000;
          const currentSpeed = sentBytes / Math.max(elapsed, 0.001);
          speedHistory.push(currentSpeed); if (speedHistory.length > 10) speedHistory.shift();
          const avg = speedHistory.reduce((a, b) => a + b, 0) / speedHistory.length;
          speedValue.textContent = `${formatFileSize(avg)}/s`;
          if (avg > 0) { const remaining = file.size - sentBytes; timeLeft.textContent = formatTime(remaining / avg); }
          // Notificar offset (opcional)
          dc.send({ type: 'progress', offset: sentBytes });
        }
      }
      showStatus(statusMessage, 'Archivo enviado con √©xito', false, true);
      setTimeout(() => { transferInfo.style.display = 'none'; }, 4000);
    }

    function waitBufferedAmountLow(dc) {
      return new Promise(resolve => {
        const check = () => { if (dc.bufferedAmount <= (dc.bufferedAmountLowThreshold || 1024 * 1024)) { dc.removeEventListener('bufferedamountlow', onLow); resolve(); } };
        const onLow = () => check();
        dc.addEventListener('bufferedamountlow', onLow, { once: true });
        // Fallback timeout por si el evento no dispara
        setTimeout(() => { dc.removeEventListener('bufferedamountlow', onLow); resolve(); }, 2000);
      });
    }

    // Copiar enlace
    copyLinkBtn.addEventListener('click', () => {
      linkInput.select();
      navigator.clipboard.writeText(linkInput.value).then(() => {
        copyLinkBtn.textContent = '¬°Copiado!';
        copyLinkBtn.setAttribute('aria-label', 'Enlace copiado');
        setTimeout(() => { copyLinkBtn.textContent = 'Copiar'; copyLinkBtn.setAttribute('aria-label', 'Copiar enlace al portapapeles'); }, 1500);
      });
    });

    // ===== Receptor si hay hash =====
    if (location.hash) { initReceiver(location.hash.substring(1)); }

    function initReceiver(hash) {
      receiverInstructions.style.display = 'none'; receiverUI.style.display = 'block';
      let channel = hash, keyB64 = null;
      if (hash.includes(':')) { const [c, k] = hash.split(':'); channel = c; keyB64 = k; }
      if (!keyB64) { showStatus(receiverStatus, 'El enlace no contiene clave (hash).', true); return; }
      // Importar clave
      const raw = Uint8Array.from(atob(keyB64), c => c.charCodeAt(0));
      crypto.subtle.importKey('raw', raw, { name: 'AES-GCM' }, false, ['decrypt']).then(receiverKey => {
        // PeerJS receptor
        peer = new Peer(undefined, PEER_OPTIONS); // id aleatorio
        attachPeerDiagnostics(peer, connTypeReceiver);
        peer.on('open', id => {
          const conn = peer.connect(channel, { reliable: true });
          if (!conn) { showStatus(receiverStatus, 'No se pudo conectar con el remitente', true); return; }
          connection = conn;
          conn.on('open', () => {
            showStatus(receiverStatus, 'Conectado al remitente. Esperando archivo...', false, true);
            let received = 0; let fileMeta = null; const chunks = [];
            conn.on('data', async (data) => {
              if (data && data.type === 'metadata') {
                fileMeta = data;
                waitingFileName.textContent = data.name; waitingFileSize.textContent = formatFileSize(data.size);
                receiverProgress.style.display = 'block'; receiverTransferredSize.textContent = `0 B / ${formatFileSize(data.size)}`;
                return;
              }
              if (data && data.type === 'progress' && fileMeta) {
                const p = (data.offset / fileMeta.size) * 100; receiverProgressBar.style.width = `${p}%`; receiverProgressText.textContent = `${p.toFixed(1)}%`; receiverTransferredSize.textContent = `${formatFileSize(data.offset)} / ${formatFileSize(fileMeta.size)}`; return;
              }
              if (data && data.type === 'chunk') {
                try {
                  const iv = new Uint8Array(data.iv);
                  const enc = new Uint8Array(data.data).buffer;
                  const dec = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, receiverKey, enc);
                  chunks.push(dec); received += dec.byteLength;
                  if (fileMeta && received >= fileMeta.size) {
                    showStatus(receiverStatus, 'Archivo recibido. Listo para descargar.', false, true);
                    downloadBtn.disabled = false;
                    downloadBtn.onclick = () => {
                      const blob = new Blob(chunks, { type: fileMeta.mimeType });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a'); a.href = url; a.download = fileMeta.name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                    };
                  }
                } catch (e) {
                  showStatus(receiverStatus, 'Error al descifrar chunk.', true);
                }
              }
            });
          });
          conn.on('error', err => showStatus(receiverStatus, `Error de conexi√≥n: ${err.message}`, true));
        });
        peer.on('error', err => showStatus(receiverStatus, `Error PeerJS: ${err.type || err.message}`, true));
      }).catch(() => showStatus(receiverStatus, 'Clave inv√°lida en el enlace.', true));
    }

    // ===== Utilidades =====
    function showStatus(el, text, isError = false, show = true) {
      el.textContent = text; el.className = 'status ' + (isError ? 'error' : 'success'); if (show) el.style.display = 'block';
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      if (bytes < 1073741824) return (bytes / 1048576).toFixed(1) + ' MB';
      return (bytes / 1073741824).toFixed(2) + ' GB';
    }

    function formatTime(seconds) {
      if (!isFinite(seconds)) return '--:--'; const m = Math.floor(seconds / 60), s = Math.floor(seconds % 60); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function generateChannelId() { return (crypto.randomUUID?.() || Math.random().toString(36).slice(2)) + Math.random().toString(36).slice(2, 10); }

    // Mostrar tipo de ruta (directo vs relay) si el peerConnection es accesible
    function attachPeerDiagnostics(peerInstance, badgeEl) {
      // PeerJS expone peer.connections[peerId][0].peerConnection (no documentado) tras conectar
      // Adem√°s, podemos inferir por candidates
      const observe = setInterval(() => {
        try {
          for (const id in peerInstance.connections) {
            const arr = peerInstance.connections[id];
            if (arr && arr[0] && arr[0].peerConnection) {
              const pc = arr[0].peerConnection;
              clearInterval(observe);
              pc.addEventListener('iceconnectionstatechange', () => {
                const st = pc.iceConnectionState; badgeEl.textContent = `ICE: ${st}`;
              });
              pc.addEventListener('connectionstatechange', () => { /* noop */ });
              pc.addEventListener('icecandidate', e => { /* noop */ });
              // Stats cada 2s para detectar si usa relay
              const probe = setInterval(async () => {
                if (pc.connectionState === 'connected' || pc.iceConnectionState === 'connected') {
                  try {
                    const stats = await pc.getStats();
                    stats.forEach(report => {
                      if (report.type === 'candidate-pair' && report.state === 'succeeded' && report.nominated) {
                        const local = stats.get(report.localCandidateId);
                        const remote = stats.get(report.remoteCandidateId);
                        if (local || remote) {
                          const via = (local?.relayProtocol || local?.candidateType) === 'relay' || (remote?.relayProtocol || remote?.candidateType) === 'relay' ? 'RELAY (TURN)' : 'DIRECTO (STUN)';
                          badgeEl.textContent = `ICE: ${via}`;
                        }
                      }
                    });
                  } catch {}
                } else if (pc.connectionState === 'failed' || pc.iceConnectionState === 'failed') {
                  badgeEl.textContent = 'ICE: FAILED (probando TURN)';
                }
              }, 2000);
            }
          }
        } catch {}
      }, 500);
      setTimeout(() => clearInterval(observe), 15000);
    }
  });
</script>

<!-- PeerJS desde CDN -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js" defer></script>
</body>
</html>
