<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>File‑share ultra‑robusto (PeerJS + fallback HTTP)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{font-family:Arial,sans-serif;margin:0;padding:1rem;background:#f5f5f5}
  .card{background:#fff;padding:1.5rem;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1);max-width:720px;margin:auto}
  h1{font-size:1.6rem;margin:0 0 .5rem}
  #info{font-size:.9rem;background:#fafafa;border:1px solid #ddd;padding:.5rem;margin-top:.5rem;border-radius:4px}
  #statusBar{margin-top:1rem;height:1.2rem;background:#e0e0e0;border-radius:4px;overflow:hidden}
  #statusBar div{height:100%;width:0;background:#4caf50;transition:width .2s}
  #link{word-break:break-all;color:#0066cc}
  button{background:#0066ff;color:#fff;border:none;padding:.5rem 1rem;border-radius:4px;cursor:pointer;margin-right:.4rem}
  button:disabled{background:#999;cursor:not-allowed}
  #msg{margin-top:.8rem;padding:.5rem;background:#fffae6;border-left:4px solid #ffeb3b}
  #langToggle{position:fixed;top:1rem;right:1rem;background:#eee;color:#333;padding:.3rem .6rem;border-radius:4px;cursor:pointer}
</style>
</head>
<body>

<div id="langToggle">🇪🇸 / 🇬🇧</div>

<div class="card">
  <h1 id="title">🔗 Compartir archivo / Share file</h1>

  <!-- ---------- SEND ---------- -->
  <div id="sender">
    <input type="file" id="fileInput">
    <p id="shareLink" style="display:none;">
      <span id="shareText">Copia y pega esta URL en el navegador del receptor</span>:
      <br><span id="link"></span>
      <button id="copyBtn">📋 Copy / Copiar</button>
    </p>
    <div id="msg"></div>
  </div>

  <!-- ---------- RECEIVE ---------- -->
  <div id="receiver" style="display:none;">
    <p><b id="recvLabel">Receiving:</b> <span id="recvName"></span></p>
    <a id="downloadBtn" style="display:none;" download>⬇️ Download / Descargar</a>
    <div id="msg"></div>
  </div>

  <!-- ---------- PROGRESS ---------- -->
  <div id="statusBar"><div></div></div>

  <!-- ---------- DEBUG PANEL ---------- -->
  <div id="info">
    <strong>🔎 Debug info</strong><br>
    <b>Peer ID:</b> <span id="myId">‑</span><br>
    <b>Remote ID:</b> <span id="remoteId">‑</span><br>
    <b>Server used:</b> <span id="serverUsed">‑</span><br>
    <b>Attempt #:</b> <span id="attemptNum">0</span><br>
    <b>Conn. state:</b> <span id="connState">‑</span><br>
    <b>RTT (ping):</b> <span id="rtt">‑</span> ms<br>
    <b>Chunk #:</b> <span id="chunkNum">‑</span><br>
    <b>Chunk size:</b> <span id="chunkSize">64 KB</span>
  </div>
</div>

<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
(() => {
  /* ==============================================================
   * 0️⃣  MULTI‑LANGUAGE TEXTS
   * ============================================================== */
  const LANG = {
    es:{title:'🔗 Compartir archivo',shareText:'Copia y pega esta URL en el navegador del receptor',copy:'📋 Copiar',copied:'✅ Copiado',waiting:'⏳ Esperando conexión…',connected:'✅ Conexión establecida',sending:'📤 Enviando archivo…',receiving:'📥 Recibiendo archivo…',download:'⬇️ Descargar',recv:'Recibiendo:',finished:'✅ Transferencia completada',dontClose:'⚠️ No cierres la ventana hasta que la descarga termine',error:'❗ Error: ',retrying:'🔄 Reintentando…',fallback:'🔁 Usando método HTTP de reserva',fallbackDone:'✅ Archivo subido, espera la URL…',fallbackFail:'❌ Fallback HTTP falló'},
    en:{title:'🔗 Share file',shareText:'Copy & paste this URL into the receiver’s browser',copy:'📋 Copy',copied:'✅ Copied',waiting:'⏳ Waiting for connection…',connected:'✅ Connected',sending:'📤 Sending file…',receiving:'📥 Receiving file…',download:'⬇️ Download',recv:'Receiving:',finished:'✅ Transfer complete',dontClose:'⚠️ Do not close the window until the download finishes',error:'❗ Error: ',retrying:'🔄 Retrying…',fallback:'🔁 Using HTTP fallback method',fallbackDone:'✅ File uploaded, waiting for URL…',fallbackFail:'❌ HTTP fallback failed'}
  };
  let curLang='es';
  const t=()=>LANG[curLang];
  const setLang=l=>{curLang=l;document.getElementById('title').textContent=t().title;document.querySelector('#shareText').textContent=t().shareText;document.getElementById('copyBtn').textContent=t().copy;document.getElementById('recvLabel').textContent=t().recv;document.getElementById('downloadBtn').textContent=t().download;};
  setLang(curLang);
  document.getElementById('langToggle').onclick=()=>setLang(curLang==='es'?'en':'es');

  /* ==============================================================
   * 1️⃣  UI HELPERS
   * ============================================================== */
  const ui = {
    fileInput:   document.getElementById('fileInput'),
    shareLink:   document.getElementById('shareLink'),
    linkSpan:    document.getElementById('link'),
    copyBtn:     document.getElementById('copyBtn'),
    sender:      document.getElementById('sender'),
    receiver:    document.getElementById('receiver'),
    recvName:    document.getElementById('recvName'),
    downloadBtn: document.getElementById('downloadBtn'),
    statusBar:   document.getElementById('statusBar').firstElementChild,
    msgArea:     document.querySelectorAll('#msg'),
    info: {
      myId:      document.getElementById('myId'),
      remoteId:  document.getElementById('remoteId'),
      server:    document.getElementById('serverUsed'),
      attempts:  document.getElementById('attemptNum'),
      conn:      document.getElementById('connState'),
      rtt:       document.getElementById('rtt'),
      chunkNum:  document.getElementById('chunkNum'),
      chunkSize: document.getElementById('chunkSize')
    }
  };
  const setMsg = m=>ui.msgArea.forEach(e=>e.textContent=m);
  const setInfo = (key,val)=>ui.info[key].textContent=val;
  const updateProgress = r=>{const p=Math.min(100,Math.round(r*100));ui.statusBar.style.width=p+'%';if(p===100)ui.statusBar.style.background='#2196F3';};

  /* ==============================================================
   * 2️⃣  SERVIDORES DE SEÑALIZACIÓN + ICE
   * ============================================================== */
  const SIGNAL_SERVERS = [
    {host:'0.peerjs.com', secure:true, port:443},
    {host:'peerjs.com',    secure:true, port:443},
    {host:'peerjs-server.herokuapp.com', secure:true, port:443},
    {host:'peerjscloud.com', secure:true, port:443}
  ];
  const ICE_SERVERS = [
    {urls:'stun:stun.l.google.com:19302'},
    {urls:'turn:global.turn.twilio.com:3478?transport=udp',username:'free',credential:'free'}
  ];

  const MAX_TIMEOUT_MS = 8000;            // tiempo máximo esperando una conexión antes de cambiar de servidor
  const MAX_RECONNECT_ATTEMPTS = 3;       // re‑intentos de reconexión en caso de caida del canal

  let peer = null;
  let serverIdx = 0;
  let connection = null;
  let isSender = false;                  // true si la página abrió como “emisor”
  let fileMeta = null;
  let fileReader = null;
  let sending = false;
  let sendSeq = 0, ackedSeq = -1;
  let resendTimer = null;
  const RESEND_TIMEOUT = 5000;
  let attempts = 0;                      // número de re‑intentos de reconexión (máximo MAX_RECONNECT_ATTEMPTS)

  /* ==============================================================
   * 3️⃣  FUNCIÓN DE CREACIÓN DE PEER CON TIMEOUT
   * ============================================================== */
  const createPeerWithTimeout = (srvIdx, onReady) => {
    const srv = SIGNAL_SERVERS[srvIdx];
    setInfo('server',srv.host);
    setInfo('attempts',srvIdx+1);
    try {
      const p = new Peer(null,{host:srv.host,secure:srv.secure,port:srv.port,config:{iceServers:ICE_SERVERS}});
      const timer = setTimeout(()=>{
        console.warn('Timeout waiting for open on',srv.host);
        p.destroy();                 // liberamos recursos
        if (srvIdx+1 < SIGNAL_SERVERS.length) createPeerWithTimeout(srvIdx+1,onReady);
        else fallbackHttp();         // ¡todos los servidores fallaron!
      },MAX_TIMEOUT_MS);
      p.on('open', id => {
        clearTimeout(timer);
        peer = p;
        setInfo('myId',id);
        console.log('Peer opened on',srv.host,'id',id);
        onReady();
      });
      p.on('error', err => {
        clearTimeout(timer);
        console.warn('Peer error on',srv.host,err);
        p.destroy();
        if (srvIdx+1 < SIGNAL_SERVERS.length) createPeerWithTimeout(srvIdx+1,onReady);
        else fallbackHttp();
      });
    } catch(e){
      console.error('Exception creating Peer',e);
      if (srvIdx+1 < SIGNAL_SERVERS.length) createPeerWithTimeout(srvIdx+1,onReady);
      else fallbackHttp();
    }
  };

  /* ==============================================================
   * 4️⃣  MÉTRICAS DE RED (PING)
   * ============================================================== */
  let pingTimer = null;
  const startPing = conn => {
    if (pingTimer) clearInterval(pingTimer);
    pingTimer = setInterval(()=>{
      const ts = Date.now();
      conn.send({type:'ping',ts});
      conn.once('data',msg=>{
        if (msg.type==='pong' && msg.ts===ts){
          const rtt = Date.now()-ts;
          setInfo('rtt',rtt);
        }
      });
    },3000);
  };

  /* ==============================================================
   * 5️⃣  EMISOR – Preparación y envío con ACK + re‑intentos
   * ============================================================== */
  ui.fileInput.addEventListener('change',()=>{
    const f = ui.fileInput.files[0];
    if (!f) return;
    fileMeta = {name:f.name,size:f.size,type:f.type};
    const url = `${location.origin}${location.pathname}?peer=${peer.id}`;
    ui.linkSpan.textContent = url;
    ui.shareLink.style.display='block';
    setMsg(t().waiting);
    isSender = true;
  });

  ui.copyBtn.addEventListener('click',async()=>{
    try{
      await navigator.clipboard.writeText(ui.linkSpan.textContent);
      ui.copyBtn.textContent = t().copied;
      setTimeout(()=>ui.copyBtn.textContent=t().copy,1500);
    }catch(e){ console.error('clipboard error',e); }
  });

  // Cuando llega una conexión entrante (emisor)
  const handleIncomingConn = conn => {
    connection = conn;
    setInfo('remoteId',conn.peer);
    setInfo('conn','open');
    setMsg(t().connected);
    startPing(conn);
    conn.on('data',msg=>{ if (msg.type==='ack') processAck(msg); });
    conn.on('close',()=>{ setInfo('conn','closed'); tryReconnect(conn); });
    conn.on('error',e=>{ setMsg(t().error+e); setInfo('conn','error'); tryReconnect(conn); });
    conn.on('open',()=>{ startSend(conn); });
  };

  const startSend = async conn => {
    if (!fileMeta) return;
    sending = true;
    sendSeq = 0;
    ackedSeq = -1;
    setMsg(t().sending);
    // 1️⃣  Metadatos
    conn.send({type:'meta',data:fileMeta});
    updateProgress(0);
    // 2️⃣  Stream del archivo
    fileReader = ui.fileInput.files[0].stream().getReader();
    sendNextChunk(conn);
  };

  const sendNextChunk = async conn => {
    // Si el último bloque ya está ack‑eado, pasamos al siguiente
    if (sendSeq <= ackedSeq) sendSeq = ackedSeq + 1;
    const start = sendSeq * 64 * 1024;
    if (start >= fileMeta.size){ return; } // todo enviado
    const {done, value} = await fileReader.read();
    if (done){ return; }
    // envío
    conn.send({type:'chunk',seq:sendSeq,data:value.buffer});
    setInfo('chunkNum',sendSeq);
    updateProgress((start+value.byteLength)/fileMeta.size);
    // timeout ACK
    clearTimeout(resendTimer);
    resendTimer = setTimeout(()=>{
      console.warn('No ACK for seq',sendSeq,'→ re‑envío');
      setMsg(t().retrying);
      // volver a leer el mismo bloque (slice manual)
      fileReader.releaseLock();
      fileReader = ui.fileInput.files[0].slice(start,start+64*1024).stream().getReader();
      sendNextChunk(conn);
    },RESEND_TIMEOUT);
    sendSeq++;
  };

  const processAck = msg => {
    ackedSeq = msg.seq;
    clearTimeout(resendTimer);
    if (ackedSeq === Math.ceil(fileMeta.size/64/1024)-1){
      setMsg(t().finished);
      sending = false;
      updateProgress(1);
      connection.send({type:'end'});
      return;
    }
    sendNextChunk(connection);
  };

  const tryReconnect = oldConn => {
    // Si aún hay bloques por enviar, intentamos reconectar (máximo 3 re‑intentos)
    if (sending && attempts < MAX_RECONNECT_ATTEMPTS){
      attempts++;
      setMsg(t().retrying+' ('+attempts+'/'+MAX_RECONNECT_ATTEMPTS+')');
      // destruimos el Peer y volvemos a crear uno sobre el **mismo** servidor
      const currentSrvIdx = serverIdx;          // guardamos índice del servidor activo
      if (peer) peer.destroy();
      setTimeout(()=>createPeerWithTimeout(currentSrvIdx,()=>{ // re‑creamos Peer
        // esperamos que el receptor vuelva a conectarse (el receptor mantendrá su Peer abierto)
        peer.on('connection',c=>{ handleIncomingConn(c); });
      }),2000);
    }else{
      setMsg(t().error+'No se pudo restablecer la conexión.');
    }
  };

  /* ==============================================================
   * 6️⃣  RECEPTOR – Manejo de bloques y ACK
   * ============================================================== */
  const urlParams = new URLSearchParams(location.search);
  const remoteId = urlParams.get('peer');

  if (remoteId){
    // modo receptor
    ui.sender.style.display='none';
    ui.receiver.style.display='block';
    setMsg(t().waiting);
    const onPeerReady = ()=>{
      const conn = peer.connect(remoteId);
      connection = conn;
      setInfo('remoteId',remoteId);
      setInfo('conn','connecting');
      conn.on('open',()=>{ setInfo('conn','open'); startPing(conn); });
      conn.on('error',e=>{ setMsg(t().error+e); setInfo('conn','error'); });
      conn.on('close',()=>{ setInfo('conn','closed'); });
      let recvMeta=null;
      let receivedChunks=[];
      let expectedSeq=0;

      conn.on('data',msg=>{
        if (msg.type==='meta'){
          recvMeta=msg.data;
          ui.recvName.textContent=recvMeta.name;
          setMsg(t().receiving);
          updateProgress(0);
          expectedSeq=0;
          receivedChunks=[];
          conn.send({type:'ack',seq:-1});
        }else if (msg.type==='chunk'){
          if (msg.seq!==expectedSeq){
            console.warn('Chunk out of order',msg.seq,'expected',expectedSeq);
            conn.send({type:'ack',seq:expectedSeq-1});
            return;
          }
          receivedChunks.push(new Uint8Array(msg.data));
          setInfo('chunkNum',msg.seq);
          updateProgress(((msg.seq+1)*64*1024)/recvMeta.size);
          conn.send({type:'ack',seq:msg.seq});
          expectedSeq++;
        }else if (msg.type==='end'){
          const blob = new Blob(receivedChunks,{type:recvMeta.type});
          const dl = URL.createObjectURL(blob);
          ui.downloadBtn.href = dl;
          ui.downloadBtn.download = recvMeta.name;
          ui.downloadBtn.style.display='inline-block';
          setMsg(t().finished);
          updateProgress(1);
          ui.downloadBtn.onclick=()=>{ downloadFinished=true; setTimeout(()=>URL.revokeObjectURL(dl),30_000); };
        }else if (msg.type==='ping'){
          conn.send({type:'pong',ts:msg.ts});
        }
      });
    };
    createPeerWithTimeout(0,onPeerReady);
  }

  /* ==============================================================
   * 7️⃣  MÉTODO HTTP FALLBACK (file.io) – última opción
   * ============================================================== */
  const fallbackHttp = async () => {
    setMsg(t().fallback);
    // Si el usuario es emisor y ya ha seleccionado un archivo, lo subimos a file.io
    if (ui.fileInput.files.length===0){
      setMsg(t().error+'No hay archivo para subir mediante fallback.');
      return;
    }
    const file = ui.fileInput.files[0];
    const form = new FormData();
    form.append('file',file);
    try{
      const resp = await fetch('https://file.io/?expires=1w', {method:'POST',body:form});
      const data = await resp.json();
      if (!data.success){
        throw new Error('file.io returned error');
      }
      const dlUrl = data.link;               // URL pública de descarga
      // Generamos URL de “parámetro” que contenga la URL de file.io
      const finalUrl = `${location.origin}${location.pathname}?fallback=${encodeURIComponent(dlUrl)}`;
      ui.linkSpan.textContent = finalUrl;
      ui.shareLink.style.display = 'block';
      setInfo('server','HTTP fallback (file.io)');
      setMsg(t().fallbackDone);
    }catch(e){
      console.error(e);
      setMsg(t().fallbackFail);
    }
  };

  /* ==============================================================
   * 8️⃣  RECEPTOR cuando llega via fallback=URL
   * ============================================================== */
  const fallbackUrl = urlParams.get('fallback');
  if (fallbackUrl && !remoteId){
    // receptor en modo fallback
    ui.sender.style.display='none';
    ui.receiver.style.display='block';
    setMsg(t().waiting);
    // Sólo mostramos botón de descarga directa
    const dl = decodeURIComponent(fallbackUrl);
    ui.downloadBtn.href = dl;
    ui.downloadBtn.download = '';          // el nombre lo decidirá el navegador
    ui.downloadBtn.style.display = 'inline-block';
    ui.downloadBtn.textContent = t().download;
    setMsg(t().finished);
  }

  /* ==============================================================
   * 9️⃣  PREVENT CLOSE
   * ============================================================== */
  let downloadFinished = false;
  window.addEventListener('beforeunload',e=>{
    if (!downloadFinished){
      e.preventDefault(); e.returnValue = t().dontClose; return t().dontClose;
    }
  });

  /* ==============================================================
   * 10️⃣  GLOBAL ERROR HANDLER
   * ============================================================== */
  window.addEventListener('error',e=>{
    console.error('Global error',e.error);
    setMsg(t().error+e.message);
  });
})();
</script>
</body>
</html>
