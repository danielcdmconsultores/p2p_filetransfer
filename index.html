<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>P2P File Share ¬∑ WebRTC + PeerJS (STUN p√∫blico)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- CSP simple y permisiva para cargar PeerJS por CDN -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' https://unpkg.com https://peerjs.com; script-src 'self' https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https: wss:; img-src 'self' data:; base-uri 'none'; frame-ancestors 'none'">
  <style>
    :root { --bg:#0b1020; --card:#141a2a; --muted:#9fb0d0; --accent:#46c3ff; --ok:#38d39f; --warn:#ffcc00; --err:#ff6677; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:white;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
    .wrap{max-width:960px;margin:auto;padding:16px}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1{font-size:1.4rem;margin:0 0 8px} h2{font-size:1.05rem;margin:14px 0 8px;color:var(--accent)}
    .row{display:grid;gap:12px;grid-template-columns:1fr} @media(min-width:720px){.row{grid-template-columns:1fr 1fr}}
    label{display:block;font-size:.9rem;margin:.4rem 0 .2rem;color:var(--muted)}
    input[type="text"],input[type="url"],input[type="number"],select{width:100%;padding:10px;border-radius:12px;border:1px solid #2a324a;background:#0f1424;color:white}
    input[type="file"]{border:1px dashed #2a324a;border-radius:12px;padding:10px;background:#0f1424;width:100%}
    button{cursor:pointer;border:0;border-radius:12px;padding:10px 14px;background:var(--accent);color:#001019;font-weight:700}
    button.ghost{background:transparent;border:1px solid #2a324a;color:#bcd}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break:break-all}
    .grid2{display:grid;gap:10px;grid-template-columns:1fr auto}
    .progress{height:14px;background:#0f1424;border-radius:999px;overflow:hidden;border:1px solid #2a324a}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#7ff);transition:width .15s}
    .status{white-space:pre-wrap;background:#0f1424;border-radius:12px;padding:12px;min-height:110px;max-height:260px;overflow:auto;border:1px solid #2a324a}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#0f1424;border:1px solid #2a324a;margin-right:6px;font-size:.8rem}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    a{color:#7fd8ff}
  </style>
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js" integrity="sha384-Nc3z3lIbjo4iC7cLW6Z0pQPCf2Bzqkbk1bAH6QOqVgd1m8J1E6b8i2rU8cG3Fv0w" crossorigin="anonymous"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>üì¶ P2P File Share (WebRTC + PeerJS)</h1>
      <p class="muted">Selecciona un fichero ‚Üí comparte la URL ‚Üí el receptor abre la URL y descarga. <strong>No cierres</strong> el navegador emisor hasta que finalice ‚úÖ.</p>

      <div class="row">
        <section>
          <h2>1) Se√±alizaci√≥n e ICE</h2>
          <div class="row">
            <div>
              <label>Servidor PeerJS (vac√≠o = Cloud)</label>
              <input id="host" type="text" placeholder="p.ej. peerjs.com o tu.domino.com">
            </div>
            <div>
              <label>Secure</label>
              <select id="secure"><option value="true" selected>true</option><option value="false">false</option></select>
            </div>
            <div>
              <label>Puerto</label>
              <input id="port" type="number" placeholder="443">
            </div>
            <div>
              <label>Path</label>
              <input id="path" type="text" placeholder="/" />
            </div>
          </div>

          <details>
            <summary>TURN (opcional para NAT muy estricto)</summary>
            <label>TURN URL (p.ej. turn:turn.example.com:3478)</label>
            <input id="turnUrl" type="text" placeholder="turn:turn.example.com:3478">
            <label>TURN usuario</label>
            <input id="turnUser" type="text" placeholder="usuario">
            <label>TURN contrase√±a</label>
            <input id="turnPass" type="text" placeholder="contrase√±a">
          </details>

          <div style="margin-top:8px">
            <button id="btnInit">Inicializar Peer</button>
            <span class="pill">Peer ID: <span id="peerId" class="mono">‚Äî</span></span>
            <span class="pill">Servidor: <span id="srvInfo" class="mono">Cloud (auto)</span></span>
          </div>
        </section>

        <section>
          <h2>2) Compartir / Recibir</h2>
          <label>Tu fichero</label>
          <input id="fileInput" type="file" />
          <div class="grid2" style="margin-top:8px">
            <button id="btnShare" disabled>Generar URL de recepci√≥n</button>
            <button id="btnCopy" class="ghost" disabled>Copiar URL</button>
          </div>
          <label>URL para receptor</label>
          <input id="shareUrl" type="url" readonly>
          <div style="margin-top:6px">
            <span class="pill">Rol: <strong id="role">auto</strong></span>
            <span class="pill">Conectado a: <span id="remoteId" class="mono">‚Äî</span></span>
          </div>

          <h2>Progreso</h2>
          <div class="progress"><div id="bar" class="bar"></div></div>
          <div class="grid2">
            <div class="muted">Enviado/Recibido: <span id="progressTxt">0 / 0</span></div>
            <div class="muted" style="text-align:right">Estado: <span id="state">Idle</span></div>
          </div>

          <div id="downloadBox" style="display:none;margin-top:10px">
            <a id="downloadLink" download class="pill">Descargar fichero recibido</a>
          </div>
        </section>
      </div>

      <h2>Logs & Diagn√≥stico</h2>
      <div class="status" id="log"></div>

      <details style="margin-top:10px">
        <summary>‚ö†Ô∏è Buenas pr√°cticas</summary>
        <ul>
          <li>No cierres ni recargues el navegador emisor hasta que la barra marque 100% y recibas confirmaci√≥n.</li>
          <li>Demo pensado para archivos moderados (el receptor ensambla en RAM). Para gigantes, usa <em>streaming</em> (StreamSaver/WritableStream) y reanudaci√≥n.</li>
          <li>Con NAT muy restrictivo, a√±ade un <strong>TURN</strong> autenticado (mejor que depender solo de STUN).</li>
        </ul>
      </details>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /*** Utilidades UI ***/
  const $ = id => document.getElementById(id);
  const log = (msg, lvl='info') => {
    const time = new Date().toLocaleTimeString();
    $('log').innerText += `[${time}] ${msg}\n`;
    $('log').scrollTop = $('log').scrollHeight;
  };
  const setState = s => $('state').innerText = s;
  const setBar = (num, den) => {
    const pct = den ? Math.min(100, Math.round((num/den)*100)) : 0;
    $('bar').style.width = pct + '%';
    $('progressTxt').innerText = human(num) + ' / ' + human(den);
  };
  const human = b => {
    if (!Number.isFinite(b)) return '0 B';
    const u = ['B','KB','MB','GB','TB']; let i=0; let n=b;
    while(n>=1024 && i<u.length-1){n/=1024;i++}
    return n.toFixed(n<10?2:1)+' '+u[i];
  };

  /*** Estado ***/
  let peer = null, conn = null;
  let isSender = false, selectedFile = null;
  let retryCount = 0; const MAX_RETRIES = 3;
  const CHUNK = 64 * 1024; // sube a 64KB: suele rendir bien y es seguro para DataChannels

  // Preconfiguraci√≥n: STUN p√∫blicos para atravesar NAT
  const DEFAULT_STUN = [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:global.stun.twilio.com:3478?transport=udp' },
    { urls: 'stun:stun.cloudflare.com:3478' }
  ];

  /*** DOM ***/
  $('btnInit').addEventListener('click', initPeer);
  $('fileInput').addEventListener('change', e => {
    selectedFile = e.target.files && e.target.files[0] ? e.target.files[0] : null;
    $('btnShare').disabled = !selectedFile || !peer || peer.disconnected;
  });
  $('btnShare').addEventListener('click', createShareUrl);
  $('btnCopy').addEventListener('click', () => {
    $('shareUrl').select(); document.execCommand('copy');
    log('URL copiada al portapapeles.');
  });

  // Rol sugerido por URL
  const url = new URL(location.href);
  const fromId = url.searchParams.get('from');
  $('role').innerText = fromId ? 'Receptor' : 'Emisor (por defecto)';

  /*** PeerJS ***/
  function buildPeerOptions(){
    const host = $('host').value.trim();
    const secure = $('secure').value === 'true';
    const port = $('port').value ? parseInt($('port').value,10) : (secure?443:80);
    const path = $('path').value.trim() || '/';

    const iceServers = [...DEFAULT_STUN];
    const turnUrl = $('turnUrl').value.trim();
    if (turnUrl) {
      const username = $('turnUser').value;
      const credential = $('turnPass').value;
      const turn = { urls: turnUrl };
      if (username) turn.username = username;
      if (credential) turn.credential = credential;
      iceServers.push(turn);
    }
    const base = { debug: 2, config: { iceServers } };
    if (host) Object.assign(base, { host, port, path, secure });
    return base;
  }

  async function initPeer(){
    if (peer && !peer.destroyed) try { peer.destroy(); } catch {}
    const opts = buildPeerOptions();
    const usingCloud = !('host' in opts);
    $('srvInfo').innerText = usingCloud ? 'Cloud (auto)' :
      `${opts.secure?'wss':'ws'}://${opts.host}:${opts.port}${opts.path}`;
    log(`Inicializando PeerJS‚Ä¶ Servidor: ${$('srvInfo').innerText}`);
    peer = new Peer(opts);

    peer.on('open', (id) => {
      $('peerId').innerText = id;
      log(`Peer abierto con ID ${id}.`);
      setState('Listo');
      if (fromId) connectTo(fromId);
    });

    peer.on('disconnected', () => {
      log('Se perdi√≥ se√±alizaci√≥n. Reintentando‚Ä¶', 'warn');
      setState('Desconectado (reintentando‚Ä¶)');
      if (retryCount < MAX_RETRIES) { retryCount++; try { peer.reconnect(); } catch {} }
      else log('L√≠mite de reintentos alcanzado.', 'err');
    });

    peer.on('error', (err) => { log('Peer error: ' + (err?.message||String(err)), 'err'); setState('Error'); });
    peer.on('close', () => { log('Peer cerrado.', 'warn'); setState('Cerrado'); });

    // Aceptar conexiones entrantes ‚Üí este ser√° el EMISOR
    peer.on('connection', (c) => {
      log(`Conexi√≥n entrante de ${c.peer}`);
      conn = c; $('remoteId').innerText = c.peer; isSender = true;
      setupDataConnHandlers(conn);
      if (selectedFile) startSend(); else log('Selecciona un fichero para empezar la transferencia.');
    });

    $('btnShare').disabled = !selectedFile;
  }

  function createShareUrl(){
    if (!peer || peer.disconnected) { log('Inicializa el Peer primero.', 'warn'); return; }
    if (!selectedFile) { log('Selecciona un fichero antes.', 'warn'); return; }
    const u = new URL(location.href);
    u.searchParams.set('from', peer.id);
    // Propagar tambi√©n la config de se√±alizaci√≥n para el receptor (opcional)
    const host = $('host').value.trim(); if (host) u.searchParams.set('host', host);
    const secure = $('secure').value; if (secure) u.searchParams.set('secure', secure);
    const port = $('port').value.trim(); if (port) u.searchParams.set('port', port);
    const path = $('path').value.trim(); if (path) u.searchParams.set('path', path);

    const share = u.toString();
    $('shareUrl').value = share;
    $('btnCopy').disabled = false;
    log('Comparte esta URL con el receptor. No cierres este navegador hasta finalizar ‚úÖ');
    setState('Esperando conexi√≥n del receptor‚Ä¶');
    alert('¬°URL lista! P√©gala en el navegador receptor. Mant√©n esta pesta√±a abierta hasta el 100%.');
  }

  function connectTo(remoteId){
    if (!peer || peer.disconnected) { log('Inicializa el Peer primero.', 'warn'); return; }
    isSender = false; $('role').innerText = 'Receptor'; $('remoteId').innerText = remoteId;
    log(`Conectando con ${remoteId}‚Ä¶`);
    conn = peer.connect(remoteId, { reliable: true, serialization: 'binary' });
    setupDataConnHandlers(conn);
  }

  function setupDataConnHandlers(c){
    c.on('open', () => {
      log('DataChannel abierto.');
      setState(isSender ? 'Listo para enviar' : 'Esperando datos‚Ä¶');
      wireDiagnostics(c);
    });
    c.on('data', handleIncomingData);
    c.on('error', (e) => { log('Conn error: ' + e.message, 'err'); setState('Error'); });
    c.on('close', () => { log('Conexi√≥n cerrada.'); if (!isSender) finalizeReceive(); });
  }

  /*** Diagn√≥stico ICE / ruta seleccionada ***/
  let statsTimer = null;
  function wireDiagnostics(c){
    try {
      const pc = c._pc || c.peerConnection || c.provider?.connections?.[c.peer]?.[0]?._pc;
      if (!pc) { log('RTCPeerConnection no accesible para estad√≠sticas (ok).'); return; }

      log(`ICE state: ${pc.iceConnectionState} ¬∑ Conn state: ${pc.connectionState}`);
      pc.addEventListener('iceconnectionstatechange', ()=>log(`ICE state ‚Üí ${pc.iceConnectionState}`));
      pc.addEventListener('connectionstatechange', ()=>log(`PeerConn state ‚Üí ${pc.connectionState}`));

      // Muestra candidate pair seleccionado (host/srflx/relay)
      if (statsTimer) clearInterval(statsTimer);
      statsTimer = setInterval(async () => {
        try {
          const stats = await pc.getStats();
          let selected = null, local = {}, remote = {};
          stats.forEach(report => {
            if (report.type === 'transport' && report.selectedCandidatePairId) {
              selected = stats.get(report.selectedCandidatePairId);
            }
          });
          if (!selected) {
            stats.forEach(r => { if (r.type === 'candidate-pair' && r.nominated && r.state === 'succeeded') selected = r; });
          }
          if (selected) {
            local = stats.get(selected.localCandidateId);
            remote = stats.get(selected.remoteCandidateId);
            if (local && remote) {
              const line = `Ruta: local=${local.candidateType}/${local.protocol}@${local.address||local.ip}:${local.port} ‚áÑ `+
                           `remoto=${remote.candidateType}/${remote.protocol}@${remote.address||remote.ip}:${remote.port}`;
              // Solo loggear si cambia
              if (wireDiagnostics._lastLine !== line) {
                wireDiagnostics._lastLine = line;
                log(line);
              }
            }
          }
        } catch {}
      }, 1000);
    } catch {}
  }

  /*** Env√≠o con backpressure real ***/
  let sendOffset = 0, sending = false;
  function startSend(){
    if (!conn || conn.open !== true) { log('No hay conexi√≥n abierta con receptor.', 'warn'); return; }
    if (!selectedFile) { log('Selecciona un fichero.', 'warn'); return; }

    // Metadatos
    const meta = { type: 'meta', name: selectedFile.name, size: selectedFile.size, mime: selectedFile.type || 'application/octet-stream' };
    conn.send(meta);
    log(`Metadatos enviados: ${meta.name} (${human(meta.size)})`);

    // Preparar DataChannel backpressure (si tiene el pc accesible)
    try {
      const pc = conn._pc || conn.peerConnection || conn.provider?.connections?.[conn.peer]?.[0]?._pc;
      const dc = pc && pc.sctp && pc.sctp.transport ? null : null; // PeerJS maneja internamente; usamos bufferSize expuesto
    } catch {}

    sendOffset = 0; setBar(0, selectedFile.size); setState('Enviando‚Ä¶');
    window.onbeforeunload = () => 'La transferencia no ha terminado. ¬øSeguro que quieres salir?';
    sending = true;

    const pump = async () => {
      if (!sending) return;
      try {
        while (conn.open && sendOffset < selectedFile.size) {
          // Control de buffer: PeerJS expone bufferSize (bytes pendientes)
          if (conn.bufferSize > 2 * 1024 * 1024) break; // pausa si > ~2MB
          const end = Math.min(sendOffset + CHUNK, selectedFile.size);
          const chunk = selectedFile.slice(sendOffset, end);
          const buf = await chunk.arrayBuffer();
          conn.send(buf);
          sendOffset = end;
          setBar(sendOffset, selectedFile.size);
        }
        if (sendOffset >= selectedFile.size) {
          conn.send({ type: 'eof' });
          setBar(selectedFile.size, selectedFile.size);
          setState('Finalizado (esperando confirmaci√≥n)‚Ä¶');
          sending = false;
        } else {
          setTimeout(pump, 20);
        }
      } catch (e) {
        log('Error durante el env√≠o: ' + e.message, 'err');
        setTimeout(pump, 200);
      }
    };
    pump();
  }

  /*** Recepci√≥n ***/
  let recvMeta = null, recvBuffers = [], receivedBytes = 0;
  function handleIncomingData(d){
    if (d && d.type === 'meta') {
      recvMeta = d; recvBuffers = []; receivedBytes = 0;
      setBar(0, recvMeta.size); setState('Recibiendo‚Ä¶');
      log(`Recibiendo: ${recvMeta.name} (${human(recvMeta.size)})`);
      return;
    }
    if (d && d.type === 'eof') { log('Fin de datos. Ensamblando‚Ä¶'); finalizeReceive(); return; }
    if (d && d.type === 'ack') {
      log('Receptor confirm√≥ la recepci√≥n ‚úÖ', 'ok');
      setState('Completado'); window.onbeforeunload = null;
      alert('Transferencia completada. Ya puedes cerrar esta pesta√±a.');
      return;
    }
    if (d instanceof ArrayBuffer) {
      recvBuffers.push(d); receivedBytes += d.byteLength;
      setBar(receivedBytes, recvMeta ? recvMeta.size : receivedBytes);
    } else if (typeof Blob !== 'undefined' && d instanceof Blob) {
      recvBuffers.push(d); receivedBytes += d.size;
      setBar(receivedBytes, recvMeta ? recvMeta.size : receivedBytes);
    }
  }

  function finalizeReceive(){
    try {
      if (!recvMeta) { log('No hay metadatos para ensamblar.'); return; }
      const blob = new Blob(recvBuffers, { type: recvMeta.mime || 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = $('downloadLink');
      a.href = url;
      a.download = sanitizeFileName(recvMeta.name || 'archivo.bin');
      $('downloadBox').style.display = '';
      setState('¬°Recibido! Descarga disponible.');
      setBar(recvMeta.size, recvMeta.size);
      log('Recepci√≥n completada. Descarga el archivo y cierra si quieres.', 'ok');
      window.onbeforeunload = null;
      if (conn && conn.open) conn.send({ type: 'ack' });
    } catch (e) {
      log('Error al ensamblar/descargar: ' + e.message, 'err');
      setState('Error en ensamblado');
    } finally {
      recvBuffers = [];
    }
  }

  function sanitizeFileName(name){
    return String(name||'archivo.bin').replace(/[^\w\-. ]+/g,'_').slice(0,180);
  }

  // Hidrataci√≥n de par√°metros de URL (para que el receptor use mismo servidor si fue especificado)
  (function hydrateFromURL(){
    const p = new URL(location.href).searchParams;
    if (p.get('host')) $('host').value = p.get('host');
    if (p.get('secure')) $('secure').value = p.get('secure');
    if (p.get('port')) $('port').value = p.get('port');
    if (p.get('path')) $('path').value = p.get('path');
  })();

  // UX: evita recarga por Enter en inputs
  document.addEventListener('keydown', e => {
    if (e.key === 'Enter' && ['INPUT','SELECT'].includes(e.target.tagName)) e.preventDefault();
  });

  // Auto-inicializar r√°pido para comodidad
  setTimeout(() => { if (!$('peerId').innerText || $('peerId').innerText==='‚Äî') initPeer(); }, 600);
})();
</script>
</body>
</html>
